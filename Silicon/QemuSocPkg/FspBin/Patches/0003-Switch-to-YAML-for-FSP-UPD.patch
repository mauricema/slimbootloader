From 44de5b7eb6005d346a33b7e9bd5491b740097d6f Mon Sep 17 00:00:00 2001
From: Maurice Ma <maurice.ma@intel.com>
Date: Sat, 12 Sep 2020 13:08:54 -0700
Subject: [PATCH] Switch to YAML for FSP UPD

Signed-off-by: Maurice Ma <maurice.ma@intel.com>
---
 BuildFsp.py                                   |  355 ++-
 BuildFsp/QEMU_FSP.yaml                        |  255 +++
 IntelFsp2Pkg/Tools/CommonUtility.py           |  132 ++
 IntelFsp2Pkg/Tools/GenCfgData.py              | 2021 +++++++++++++++++
 IntelFsp2Pkg/Tools/GenCfgOpt.py               | 1549 -------------
 QemuFspPkg/Include/FspUpd.h                   |   48 -
 QemuFspPkg/Include/FspmUpd.h                  |  108 -
 QemuFspPkg/Include/FspsUpd.h                  |  101 -
 QemuFspPkg/Include/FsptUpd.h                  |  101 -
 .../Library/PlatformSecLib/PlatformSecLib.h   |    1 +
 QemuFspPkg/QemuFspPkg.dsc                     |  188 --
 QemuFspPkg/QemuFspUpd.yaml                    |  255 +++
 12 files changed, 2836 insertions(+), 2278 deletions(-)
 create mode 100644 BuildFsp/QEMU_FSP.yaml
 create mode 100644 IntelFsp2Pkg/Tools/CommonUtility.py
 create mode 100644 IntelFsp2Pkg/Tools/GenCfgData.py
 delete mode 100644 IntelFsp2Pkg/Tools/GenCfgOpt.py
 delete mode 100644 QemuFspPkg/Include/FspUpd.h
 delete mode 100644 QemuFspPkg/Include/FspmUpd.h
 delete mode 100644 QemuFspPkg/Include/FspsUpd.h
 delete mode 100644 QemuFspPkg/Include/FsptUpd.h
 create mode 100644 QemuFspPkg/QemuFspUpd.yaml

diff --git a/BuildFsp.py b/BuildFsp.py
index 963266aede..1d521c0d9d 100644
--- a/BuildFsp.py
+++ b/BuildFsp.py
@@ -27,172 +27,172 @@ import subprocess
 import multiprocessing
 from ctypes import *
 
-def get_file_data (file, mode = 'rb'):
-    return open(file, mode).read()
-
-def run_process (arg_list, print_cmd = False, capture_out = False):
-    sys.stdout.flush()
-    if print_cmd:
-        print (' '.join(arg_list))
-
-    exc    = None
-    result = 0
-    output = ''
-    try:
-        if capture_out:
-            output = subprocess.check_output(arg_list).decode()
-        else:
-            result = subprocess.call (arg_list)
-    except Exception as ex:
-        result = 1
-        exc    = ex
-
-    if result:
-        if not print_cmd:
-            print ('Error in running process:\n  %s' % ' '.join(arg_list))
-        if exc is None:
-            sys.exit(1)
-        else:
-            raise exc
-
-    return output
-
-
-def check_files_exist (base_name_list, dir = '', ext = ''):
-    for each in base_name_list:
-        if not os.path.exists (os.path.join (dir, each + ext)):
-            return False
-    return True
-
-
-def get_visual_studio_info ():
-
-    toolchain        = ''
-    toolchain_prefix = ''
-    toolchain_path   = ''
-    toolchain_ver    = ''
-
-    # check new Visual Studio Community version first
-    vswhere_path = "%s/Microsoft Visual Studio/Installer/vswhere.exe" % os.environ['ProgramFiles(x86)']
-    if os.path.exists (vswhere_path):
-        cmd = [vswhere_path, '-all', '-property', 'installationPath']
-        lines = run_process (cmd, capture_out = True)
-        vscommon_path = ''
-        for each in lines.splitlines ():
-            each = each.strip()
-            if each and os.path.isdir(each):
-                vscommon_path = each
-        vcver_file = vscommon_path + '\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt'
-        if os.path.exists(vcver_file):
-            for vs_ver in ['2017']:
-                check_path = '\\Microsoft Visual Studio\\%s\\' % vs_ver
-                if check_path in vscommon_path:
-                    toolchain_ver    = get_file_data (vcver_file, 'r').strip()
-                    toolchain_prefix = 'VS%s_PREFIX' % (vs_ver)
-                    toolchain_path   = vscommon_path + '\\VC\\Tools\\MSVC\\%s\\' % toolchain_ver
-                    toolchain='VS%s' % (vs_ver)
-                    break
-
-    if toolchain == '':
-        vs_ver_list = [
-            ('2015', 'VS140COMNTOOLS'),
-            ('2013', 'VS120COMNTOOLS')
-        ]
-        for vs_ver, vs_tool in vs_ver_list:
-            if vs_tool in os.environ:
-                toolchain        ='VS%s%s' % (vs_ver, 'x86')
-                toolchain_prefix = 'VS%s_PREFIX' % (vs_ver)
-                toolchain_path   = os.path.join(os.environ[vs_tool], '..//..//')
-                toolchain_ver    = vs_ver
-                parts   = os.environ[vs_tool].split('\\')
-                vs_node = 'Microsoft Visual Studio '
-                for part in parts:
-                    if part.startswith(vs_node):
-                        toolchain_ver = part[len(vs_node):]
-                break
-    return (toolchain, toolchain_prefix, toolchain_path, toolchain_ver)
-
-
-def rebuild_basetools ():
-    exe_list = 'GenFfs  GenFv  GenFw  GenSec LzmaCompress'.split()
+def get_file_data (file, mode = 'rb'):
+    return open(file, mode).read()
+
+def run_process (arg_list, print_cmd = False, capture_out = False):
+    sys.stdout.flush()
+    if print_cmd:
+        print (' '.join(arg_list))
+
+    exc    = None
+    result = 0
+    output = ''
+    try:
+        if capture_out:
+            output = subprocess.check_output(arg_list).decode()
+        else:
+            result = subprocess.call (arg_list)
+    except Exception as ex:
+        result = 1
+        exc    = ex
+
+    if result:
+        if not print_cmd:
+            print ('Error in running process:\n  %s' % ' '.join(arg_list))
+        if exc is None:
+            sys.exit(1)
+        else:
+            raise exc
+
+    return output
+
+
+def check_files_exist (base_name_list, dir = '', ext = ''):
+    for each in base_name_list:
+        if not os.path.exists (os.path.join (dir, each + ext)):
+            return False
+    return True
+
+
+def get_visual_studio_info ():
+
+    toolchain        = ''
+    toolchain_prefix = ''
+    toolchain_path   = ''
+    toolchain_ver    = ''
+
+    # check new Visual Studio Community version first
+    vswhere_path = "%s/Microsoft Visual Studio/Installer/vswhere.exe" % os.environ['ProgramFiles(x86)']
+    if os.path.exists (vswhere_path):
+        cmd = [vswhere_path, '-all', '-property', 'installationPath']
+        lines = run_process (cmd, capture_out = True)
+        vscommon_path = ''
+        for each in lines.splitlines ():
+            each = each.strip()
+            if each and os.path.isdir(each):
+                vscommon_path = each
+        vcver_file = vscommon_path + '\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt'
+        if os.path.exists(vcver_file):
+            for vs_ver in ['2017']:
+                check_path = '\\Microsoft Visual Studio\\%s\\' % vs_ver
+                if check_path in vscommon_path:
+                    toolchain_ver    = get_file_data (vcver_file, 'r').strip()
+                    toolchain_prefix = 'VS%s_PREFIX' % (vs_ver)
+                    toolchain_path   = vscommon_path + '\\VC\\Tools\\MSVC\\%s\\' % toolchain_ver
+                    toolchain='VS%s' % (vs_ver)
+                    break
+
+    if toolchain == '':
+        vs_ver_list = [
+            ('2015', 'VS140COMNTOOLS'),
+            ('2013', 'VS120COMNTOOLS')
+        ]
+        for vs_ver, vs_tool in vs_ver_list:
+            if vs_tool in os.environ:
+                toolchain        ='VS%s%s' % (vs_ver, 'x86')
+                toolchain_prefix = 'VS%s_PREFIX' % (vs_ver)
+                toolchain_path   = os.path.join(os.environ[vs_tool], '..//..//')
+                toolchain_ver    = vs_ver
+                parts   = os.environ[vs_tool].split('\\')
+                vs_node = 'Microsoft Visual Studio '
+                for part in parts:
+                    if part.startswith(vs_node):
+                        toolchain_ver = part[len(vs_node):]
+                break
+    return (toolchain, toolchain_prefix, toolchain_path, toolchain_ver)
+
+
+def rebuild_basetools ():
+    exe_list = 'GenFfs  GenFv  GenFw  GenSec LzmaCompress'.split()
     ret = 0
     workspace = os.environ['WORKSPACE']
 
-    cmd = [sys.executable, '-c', 'import sys; import platform; print(", ".join([sys.executable, platform.python_version()]))']
-    py_out = run_process (cmd, capture_out = True)
-    parts  = py_out.split(',')
-    if len(parts) > 1:
-        py_exe, py_ver = parts
-        os.environ['PYTHON_COMMAND'] = py_exe
-        print ('Using %s, Version %s' % (os.environ['PYTHON_COMMAND'], py_ver.rstrip()))
-    else:
-        os.environ['PYTHON_COMMAND'] = 'python'
-
+    cmd = [sys.executable, '-c', 'import sys; import platform; print(", ".join([sys.executable, platform.python_version()]))']
+    py_out = run_process (cmd, capture_out = True)
+    parts  = py_out.split(',')
+    if len(parts) > 1:
+        py_exe, py_ver = parts
+        os.environ['PYTHON_COMMAND'] = py_exe
+        print ('Using %s, Version %s' % (os.environ['PYTHON_COMMAND'], py_ver.rstrip()))
+    else:
+        os.environ['PYTHON_COMMAND'] = 'python'
+
     if os.name == 'posix':
-        if not check_files_exist (exe_list, os.path.join(workspace, 'BaseTools', 'Source', 'C', 'bin')):
+        if not check_files_exist (exe_list, os.path.join(workspace, 'BaseTools', 'Source', 'C', 'bin')):
             ret = subprocess.call(['make', '-C', 'BaseTools'])
 
     elif os.name == 'nt':
-
-        if not check_files_exist (exe_list, os.path.join(workspace, 'BaseTools', 'Bin', 'Win32'), '.exe'):
-            print ("Could not find pre-built BaseTools binaries, try to rebuild BaseTools ...")
-            ret = run_process (['BaseTools\\toolsetup.bat', 'forcerebuild'])
+
+        if not check_files_exist (exe_list, os.path.join(workspace, 'BaseTools', 'Bin', 'Win32'), '.exe'):
+            print ("Could not find pre-built BaseTools binaries, try to rebuild BaseTools ...")
+            ret = run_process (['BaseTools\\toolsetup.bat', 'forcerebuild'])
 
     if ret:
-        print ("Build BaseTools failed, please check required build environment and utilities !")
+        print ("Build BaseTools failed, please check required build environment and utilities !")
         sys.exit(1)
 
 
 def prep_env():
-    work_dir = os.path.dirname(os.path.realpath(__file__))
-    os.chdir(work_dir)
-    if sys.platform == 'darwin':
-        toolchain = 'XCODE5'
-        os.environ['PATH'] = os.environ['PATH'] + ':' + os.path.join(work_dir, 'BaseTools/BinWrappers/PosixLike')
-        clang_ver = run_process (['clang', '-dumpversion'], capture_out = True)
-        clang_ver = clang_ver.strip()
-        toolchain_ver = clang_ver
-    elif os.name == 'posix':
+    work_dir = os.path.dirname(os.path.realpath(__file__))
+    os.chdir(work_dir)
+    if sys.platform == 'darwin':
+        toolchain = 'XCODE5'
+        os.environ['PATH'] = os.environ['PATH'] + ':' + os.path.join(work_dir, 'BaseTools/BinWrappers/PosixLike')
+        clang_ver = run_process (['clang', '-dumpversion'], capture_out = True)
+        clang_ver = clang_ver.strip()
+        toolchain_ver = clang_ver
+    elif os.name == 'posix':
         toolchain = 'GCC49'
         gcc_ver = subprocess.Popen(['gcc', '-dumpversion'], stdout=subprocess.PIPE)
         (gcc_ver, err) = subprocess.Popen(['sed', 's/\\..*//'], stdin=gcc_ver.stdout, stdout=subprocess.PIPE).communicate()
         if int(gcc_ver) > 4:
             toolchain = 'GCC5'
 
-        os.environ['PATH'] = os.environ['PATH'] + ':' + os.path.join(work_dir, 'BaseTools/BinWrappers/PosixLike')
-        toolchain_ver = gcc_ver
+        os.environ['PATH'] = os.environ['PATH'] + ':' + os.path.join(work_dir, 'BaseTools/BinWrappers/PosixLike')
+        toolchain_ver = gcc_ver
     elif os.name == 'nt':
-        os.environ['PATH'] = os.environ['PATH'] + ';' + os.path.join(work_dir, 'BaseTools\\Bin\\Win32')
-        os.environ['PATH'] = os.environ['PATH'] + ';' + os.path.join(work_dir, 'BaseTools\\BinWrappers\\WindowsLike')
-        os.environ['PYTHONPATH'] = os.path.join(work_dir, 'BaseTools', 'Source', 'Python')
-
-        toolchain, toolchain_prefix, toolchain_path, toolchain_ver = get_visual_studio_info ()
-        if toolchain:
-            os.environ[toolchain_prefix] = toolchain_path
-        else:
-            print("Could not find supported Visual Studio version !")
+        os.environ['PATH'] = os.environ['PATH'] + ';' + os.path.join(work_dir, 'BaseTools\\Bin\\Win32')
+        os.environ['PATH'] = os.environ['PATH'] + ';' + os.path.join(work_dir, 'BaseTools\\BinWrappers\\WindowsLike')
+        os.environ['PYTHONPATH'] = os.path.join(work_dir, 'BaseTools', 'Source', 'Python')
+
+        toolchain, toolchain_prefix, toolchain_path, toolchain_ver = get_visual_studio_info ()
+        if toolchain:
+            os.environ[toolchain_prefix] = toolchain_path
+        else:
+            print("Could not find supported Visual Studio version !")
             sys.exit(1)
         if 'NASM_PREFIX' not in os.environ:
             os.environ['NASM_PREFIX'] = "C:\\Nasm\\"
         if 'OPENSSL_PATH' not in os.environ:
             os.environ['OPENSSL_PATH'] = "C:\\Openssl\\"
-        if 'IASL_PREFIX' not in os.environ:
-            os.environ['IASL_PREFIX'] = "C:\\ASL\\"
+        if 'IASL_PREFIX' not in os.environ:
+            os.environ['IASL_PREFIX'] = "C:\\ASL\\"
     else:
-        print("Unsupported operating system !")
+        print("Unsupported operating system !")
         sys.exit(1)
 
-    print ('Using %s, Version %s' % (toolchain, toolchain_ver))
+    print ('Using %s, Version %s' % (toolchain, toolchain_ver))
 
-    # Update Environment vars
-    os.environ['EDK_TOOLS_PATH'] = os.path.join(work_dir, 'BaseTools')
-    os.environ['BASE_TOOLS_PATH'] = os.path.join(work_dir, 'BaseTools')
-    if 'WORKSPACE' not in os.environ:
-        os.environ['WORKSPACE'] = work_dir
-    os.environ['CONF_PATH']     = os.path.join(os.environ['WORKSPACE'], 'Conf')
-    os.environ['TOOL_CHAIN']    = toolchain
+    # Update Environment vars
+    os.environ['EDK_TOOLS_PATH'] = os.path.join(work_dir, 'BaseTools')
+    os.environ['BASE_TOOLS_PATH'] = os.path.join(work_dir, 'BaseTools')
+    if 'WORKSPACE' not in os.environ:
+        os.environ['WORKSPACE'] = work_dir
+    os.environ['CONF_PATH']     = os.path.join(os.environ['WORKSPACE'], 'Conf')
+    os.environ['TOOL_CHAIN']    = toolchain
 
-    return (work_dir, toolchain)
+    return (work_dir, toolchain)
 
 
 def Fatal(msg):
@@ -214,9 +214,9 @@ def CopyFileList (copy_list, fsp_dir, sbl_dir):
 
 def Prebuild(target, toolchain):
 
-    rebuild_basetools ()
+    rebuild_basetools ()
 
-    workspace = os.environ['WORKSPACE']
+    workspace = os.environ['WORKSPACE']
     if not os.path.exists(os.path.join(workspace, 'Conf')):
         os.makedirs(os.path.join(workspace, 'Conf'))
     for name in ['target', 'tools_def', 'build_rule']:
@@ -226,14 +226,12 @@ def Prebuild(target, toolchain):
               os.path.join(workspace, 'BaseTools/Conf/%s.template' % name),
               os.path.join(workspace, 'Conf/%s.txt' % name))
 
-    #
-    # Not needed any more since EDKII already supported to list non-existing file in FDF
-    #
-    # cmd = '%s -p QemuFspPkg/QemuFspPkg.dsc -m QemuFspPkg/FspHeader/FspHeader.inf -a IA32 -b %s -t %s -DCFG_PREBUILD' % (
-    #     'build' if os.name == 'posix' else 'build.bat', target, toolchain)
-    # ret = subprocess.call(cmd.split(' '))
-    # if ret:
-    #     Fatal('Failed to prebuild QEMU FSP !')
+    fspbase = 'QemuFsp'
+    pkgname = fspbase + 'Pkg'
+    updname = fspbase + 'Upd'
+    fvdir = 'Build/%s/%s_%s/FV' % (pkgname, target, toolchain)
+    if not os.path.exists (fvdir):
+        os.makedirs(fvdir)
 
     FspGuid = {
         'FspTUpdGuid'       : '34686CA3-34F9-4901-B82A-BA630F0714C6',
@@ -242,48 +240,39 @@ def Prebuild(target, toolchain):
     }
 
     # !!!!!!!! Update VPD/UPD Information !!!!!!!!
-    print('Preparing VPD/UPD Information...')
+    print('Preparing UPD Information...')
 
-    pkgname = 'QemuFspPkg'
-    cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgOpt.py UPDTXT %s/%s.dsc Build/%s/%s_%s/FV' % (
-           workspace, pkgname, pkgname, pkgname, target, toolchain)
+    # Generate combined YAML file
+    cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgData.py GENYML %s/%s.yaml Build/%s/%s_%s/FV/%s.yaml' % (
+           workspace, pkgname, updname, pkgname, target, toolchain, fspbase)
     ret = subprocess.call(cmd.split(' '))
-    if not (ret == 0 or ret == 256):
-        Fatal('Failed to generate UPD txt file !')
+    if not (ret == 0):
+        Fatal('Failed to generate combined YAML file !')
 
-    print('UPD TXT file was generated successfully !')
+    print('Generate UPD Bianry File ...')
+    for fsp_comp in 'TMS':
+        cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgData.py GENBIN %s/%s.yaml@FSP%s_UPD Build/%s/%s_%s/FV/%s.bin' % (
+               workspace, pkgname, updname, fsp_comp, pkgname, target, toolchain, FspGuid['Fsp%sUpdGuid' % fsp_comp])
+        ret = subprocess.call(cmd.split(' '))
+        if not (ret == 0):
+            Fatal('Failed to generate UPD binary file !')
 
     print('Generate UPD Header File ...')
-    bdpgpath = 'BPDG' if os.name == 'posix' else 'BPDG.bat'
-
-    fvdir = 'Build/%s/%s_%s/FV' % (pkgname, target, toolchain)
-    for fspcomp in FspGuid:
-        fspguid = FspGuid[fspcomp]
-        cmd = '%s %s/%s.txt' % (bdpgpath, fvdir, fspguid)
-        cmd = cmd + ' -o %s/%s.bin' % (fvdir, fspguid)
-        cmd = cmd + ' -m %s/%s.map' % (fvdir, fspguid)
-        filepath = '%s/%s/%s.bin' % (workspace, fvdir, fspguid)
-        if os.path.exists(filepath):
-            os.remove(filepath)
+    for fsp_comp in 'TMS ':
+        if fsp_comp == ' ':
+            fsp_comp = ''
+            scope = 'FSP_SIG'
+        else:
+            scope = 'FSP%s_UPD' % fsp_comp
+        fliename = 'Fsp%sUpd.h' % fsp_comp.lower()
+        cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgData.py GENHDR %s/%s.yaml@%s %s/%s' % (
+               workspace, pkgname, updname, scope, fvdir, fliename)
         ret = subprocess.call(cmd.split(' '))
-        if ret:
-            Fatal('Failed to generate UPD bin file !')
-
-    cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgOpt.py HEADER %s/%s.dsc Build/%s/%s_%s/FV %s/Include/BootLoaderPlatformData.h' % (
-          workspace, pkgname, pkgname, pkgname, target, toolchain, pkgname)
-    ret = subprocess.call(cmd.split(' '))
-    if ret:
-        Fatal('Failed to generate UPD header file !')
-
-    print('Generate BSF File ...')
-    cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgOpt.py GENBSF %s/%s.dsc Build/%s/%s_%s/FV %s/QemuFsp.bsf' % (
-          workspace, pkgname, pkgname, pkgname, target, toolchain, fvdir)
-    ret = subprocess.call(cmd.split(' '))
-    if ret:
-        Fatal('Failed to generate UPD BSF file !')
+        if not (ret == 0):
+            Fatal('Failed to generate UPD header file !')
 
-    for fliename in ['FspUpd.h', 'FsptUpd.h', 'FspmUpd.h', 'FspsUpd.h']:
         shutil.copyfile('%s/%s' % (fvdir, fliename), '%s/Include/%s'%(pkgname, fliename))
+
     print('End of PreBuild...')
 
 
@@ -356,8 +345,8 @@ def PostBuild (target, toolchain):
             Fatal('Failed to do PostBuild QEMU FSP!')
 
     copy_list = [
-        ('QEMUFSP.fd',  'QEMU_FSP_%s.fd' % target),
-        ('QemuFsp.bsf', 'QEMU_FSP.bsf'),
+        ('QEMUFSP.fd',   'QEMU_FSP_%s.fd' % target),
+        ('QemuFsp.yaml', 'QEMU_FSP.yaml'),
         ('FspUpd.h',    'FspUpd.h'),
         ('FsptUpd.h',   'FsptUpd.h'),
         ('FspmUpd.h',   'FspmUpd.h'),
@@ -386,7 +375,7 @@ def Main():
             return -1
 
     workspace, toolchain = prep_env()
-    os.environ['WORKSPACE'] = workspace
+    os.environ['WORKSPACE'] = workspace
     Prebuild  (target, toolchain)
     Build     (target, toolchain)
     PostBuild (target, toolchain)
diff --git a/BuildFsp/QEMU_FSP.yaml b/BuildFsp/QEMU_FSP.yaml
new file mode 100644
index 0000000000..1b95866059
--- /dev/null
+++ b/BuildFsp/QEMU_FSP.yaml
@@ -0,0 +1,255 @@
+## @file
+#
+#  Slim Bootloader CFGDATA Default File.
+#
+#  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+
+variable:
+  FSP_PACKAGE                    : QemuFspPkg
+  FSP_IMAGE_ID                   : 0x245053464D455124  # $QEMFSP$
+  FSP_IMAGE_REV                  : 0x00001000
+  CAR_BASE_ADDRESS               : 0x00000000
+  CAR_REGION_SIZE                : 0x00080000
+  CAR_BLD_REGION_SIZE            : 0x00070000
+  CAR_FSP_REGION_SIZE            : 0x00010000
+  PLATFORM_NAME                  : QemuFspPkg
+  PLATFORM_GUID                  : 1BEDB57A-7904-406e-8486-C89FC7FB39EE
+  PLATFORM_VERSION               : 0.1
+  DSC_SPECIFICATION              : 0x00010005
+  OUTPUT_DIRECTORY               : Build/QemuFspPkg
+  SUPPORTED_ARCHITECTURES        : IA32
+  BUILD_TARGETS                  : DEBUG|RELEASE
+  SKUID_IDENTIFIER               : DEFAULT
+  FLASH_DEFINITION               : QemuFspPkg/QemuFspPkg.fdf
+  FSP_T_UPD_TOOL_GUID            : 34686CA3-34F9-4901-B82A-BA630F0714C6
+  FSP_M_UPD_TOOL_GUID            : 39A250DB-E465-4DD1-A2AC-E2BD3C0E2385
+  FSP_S_UPD_TOOL_GUID            : CAE3605B-5B34-4C85-B3D7-27D54273C40F
+  FSP_T_UPD_FFS_GUID             : 70BCF6A5-FFB1-47D8-B1AE-EFE5508E23EA
+  FSP_M_UPD_FFS_GUID             : D5B86AEA-6AF7-40D4-8014-982301BC3D89
+  FSP_S_UPD_FFS_GUID             : E3CD9B18-998C-4F76-B65E-98B154E5446F
+
+
+template:
+
+
+configs:
+  - $ACTION      :
+      page         : MEM::"FSP MemoryInit Settings", SIL::"FSP SiliconInit Settings"
+
+  - FSPT_UPD:
+
+    - FSP_UPD_HEADER :
+      - Signature    :
+          length       : 0x08
+          value        : 0x545F4450554D4551
+      - Revision     :
+          name         : FsptUpdRevision
+          type         : None
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x17
+          value        : {0x00}
+
+    - FSPT_COMMON_UPD :
+      - Revision     :
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x03
+          value        : {0x00}
+      - MicrocodeRegionBase :
+          length       : 0x04
+          value        : 0x00000000
+      - MicrocodeRegionLength :
+          length       : 0x04
+          value        : 0x00000000
+      - CodeRegionBase :
+          length       : 0x04
+          value        : 0x00000000
+      - CodeRegionLength :
+          length       : 0x04
+          value        : 0x00000000
+      - Reserved1    :
+          length       : 0x0C
+          value        : {0x00}
+
+    - FSPT_CONFIG :
+      - ReservedFsptUpd1 :
+          length       : 0x20
+          value        : {0x00}
+      - UnusedUpdSpace0 :
+          length       : 0x30
+          value        : { 0 }
+      - UpdTerminator :
+          length       : 0x02
+          value        : 0x55AA
+
+  - FSPM_UPD:
+    - FSP_UPD_HEADER :
+      - Signature    :
+          length       : 0x08
+          value        : 0x4D5F4450554D4551
+      - Revision     :
+          name         : FspmUpdRevision
+          type         : None
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x17
+          value        : {0x00}
+
+    - FSPM_ARCH_UPD :
+      - $ACTION      :
+          page         : MEM
+      - Revision     :
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x03
+          value        : {0x00}
+      - NvsBufferPtr :
+          struct       : VOID*
+          length       : 0x04
+          value        : 0x00000000
+      - StackBase    :
+          struct       : VOID*
+          name         : StackBase
+          help         : >
+                         Stack base for FSP use. Default- 0xFEF16000
+          length       : 0x04
+          value        : $(CAR_BLD_REGION_SIZE)
+      - StackSize    :
+          name         : StackSize
+          help         : >
+                         To pass the stack size for FSP use. Bootloader can programmatically get the FSP requested StackSize by using the defaults in the FSP-M component. This is the minimum stack size expected by this revision of FSP. Default- 0x2A000
+          length       : 0x04
+          value        : $(CAR_FSP_REGION_SIZE)
+      - BootLoaderTolumSize :
+          name         : BootLoaderTolumSize
+          help         : >
+                         To pass Bootloader Tolum size.
+          length       : 0x04
+          value        : 0x00000000
+      - Bootmode     :
+          name         : Bootmode
+          help         : >
+                         To maintain Bootmode details.
+          length       : 0x04
+          value        : 0x00000000
+      - Reserved1    :
+          length       : 0x08
+          value        : {0x00}
+
+    - FSPM_CONFIG :
+      - SerialDebugPortAddress :
+          name         : Debug Serial Port Base address
+          type         : EditNum, HEX, (0x00000000,0xFFFFFFFF)
+          help         : >
+                         Debug serial port base address. This option will be used only when the 'Serial Port Debug Device'
+                         option is set to 'External Device'. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - SerialDebugPortType :
+          name         : Debug Serial Port Type
+          type         : Combo
+          option       : 0:NONE, 1:I/O, 2:MMIO
+          help         : >
+                         16550 compatible debug serial port resource type. NONE means no serial port support. 0x02:MMIO(Default).
+          length       : 0x01
+          value        : 0x02
+      - SerialDebugPortDevice :
+          name         : Serial Port Debug Device
+          type         : Combo
+          option       : 0:SOC UART0, 1:SOC UART1, 2:SOC UART2, 3:External Device
+          help         : >
+                         Select active serial port device for debug.
+                         For SOC UART devices,'Debug Serial Port Base' options will be ignored. 0x02:SOC UART2(Default).
+          length       : 0x01
+          value        : 0x02
+      - SerialDebugPortStrideSize :
+          name         : Debug Serial Port Stride Size
+          type         : Combo
+          option       : 0:1, 2:4
+          help         : >
+                         Debug serial port register map stride size in bytes. 0x00:1, 0x02:4(Default).
+          length       : 0x01
+          value        : 0x02
+
+      - UnusedUpdSpace1 :
+          length       : 0x31
+          value        : { 0 }
+      - ReservedFspmUpd :
+          length       : 0x04
+          value        : {0x00}
+      - UnusedUpdSpace2 :
+          length       : 0x2
+          value        : { 0 }
+      - UpdTerminator :
+          length       : 0x02
+          value        : 0x55AA
+
+  - FSPS_UPD:
+    - FSP_UPD_HEADER :
+      - Signature    :
+          length       : 0x08
+          value        : 0x535F4450554D4551
+      - Revision     :
+          name         : FspsUpdRevision
+          type         : None
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x17
+          value        : {0x00}
+
+    - FSPS_CONFIG :
+      - $ACTION      :
+          page         : SIL
+      - UnusedUpdSpace3 :
+          length       : 0x20
+          value        : { 0 }
+      - LogoSize     :
+          name         : BMP Logo Data Size
+          type         : Reserved
+          help         : >
+                         BMP logo data buffer size. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - LogoPtr      :
+          name         : BMP Logo Data Pointer
+          type         : Reserved
+          help         : >
+                         BMP logo data pointer to a BMP format buffer. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - GraphicsConfigPtr :
+          name         : Graphics Configuration Data Pointer
+          type         : Reserved
+          help         : >
+                         Graphics configuration data used for initialization. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - PciTempResourceBase :
+          name         : PCI Temporary MMIO Base
+          type         : Reserved
+          help         : >
+                         PCI Temporary MMIO Base used before full PCI enumeration. 0x80000000(Default).
+          length       : 0x04
+          value        : 0x80000000
+      - UnusedUpdSpace4 :
+          length       : 0x20
+          value        : { 0 }
+      - ReservedFspsUpd :
+          length       : 0x01
+          value        : 0x00
+      - UnusedUpdSpace5 :
+          length       : 0xd
+          value        : { 0 }
+      - UpdTerminator :
+          length       : 0x02
+          value        : 0x55AA
\ No newline at end of file
diff --git a/IntelFsp2Pkg/Tools/CommonUtility.py b/IntelFsp2Pkg/Tools/CommonUtility.py
new file mode 100644
index 0000000000..a3c3e7984e
--- /dev/null
+++ b/IntelFsp2Pkg/Tools/CommonUtility.py
@@ -0,0 +1,132 @@
+#!/usr/bin/env python
+## @ CommonUtility.py
+# Common utility script
+#
+# Copyright (c) 2016 - 2020, Intel Corporation. All rights reserved.<BR>
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+##
+# Import Modules
+#
+import os
+import sys
+import re
+import shutil
+import subprocess
+import struct
+import hashlib
+import string
+from   functools import reduce
+from   ctypes import *
+
+def print_bytes (data, indent=0, offset=0, show_ascii = False):
+    bytes_per_line = 16
+    printable = ' ' + string.ascii_letters + string.digits + string.punctuation
+    str_fmt = '{:s}{:04x}: {:%ds} {:s}' % (bytes_per_line * 3)
+    bytes_per_line
+    data_array = bytearray(data)
+    for idx in range(0, len(data_array), bytes_per_line):
+        hex_str = ' '.join('%02X' % val for val in data_array[idx:idx + bytes_per_line])
+        asc_str = ''.join('%c' % (val if (chr(val) in printable) else '.')
+                          for val in data_array[idx:idx + bytes_per_line])
+        print (str_fmt.format(indent * ' ', offset + idx, hex_str, ' ' + asc_str if show_ascii else ''))
+
+def get_bits_from_bytes (bytes, start, length):
+    if length == 0:
+        return 0
+    byte_start = (start)  // 8
+    byte_end   = (start + length - 1) // 8
+    bit_start  = start & 7
+    mask = (1 << length) - 1
+    val = bytes_to_value (bytes[byte_start:byte_end + 1])
+    val = (val >> bit_start) & mask
+    return val
+
+def set_bits_to_bytes (bytes, start, length, bvalue):
+    if length == 0:
+        return
+    byte_start = (start)  // 8
+    byte_end   = (start + length - 1) // 8
+    bit_start  = start & 7
+    mask = (1 << length) - 1
+    val  = bytes_to_value (bytes[byte_start:byte_end + 1])
+    val &= ~(mask << bit_start)
+    val |= ((bvalue & mask) << bit_start)
+    bytes[byte_start:byte_end+1] = value_to_bytearray (val, byte_end + 1 - byte_start)
+
+def value_to_bytes (value, length):
+    return value.to_bytes(length, 'little')
+
+def bytes_to_value (bytes):
+    return int.from_bytes (bytes, 'little')
+
+def value_to_bytearray (value, length):
+    return bytearray(value_to_bytes(value, length))
+
+def value_to_bytearray (value, length):
+    return bytearray(value_to_bytes(value, length))
+
+def get_aligned_value (value, alignment = 4):
+    if alignment != (1 << (alignment.bit_length() - 1)):
+        raise Exception ('Alignment (0x%x) should to be power of 2 !' % alignment)
+    value = (value + (alignment - 1)) & ~(alignment - 1)
+    return value
+
+def get_padding_length (data_len, alignment = 4):
+    new_data_len = get_aligned_value (data_len, alignment)
+    return new_data_len - data_len
+
+def get_file_data (file, mode = 'rb'):
+    return open(file, mode).read()
+
+def gen_file_from_object (file, object):
+    open (file, 'wb').write(object)
+
+def gen_file_with_size (file, size):
+    open (file, 'wb').write(b'\xFF' * size);
+
+def check_files_exist (base_name_list, dir = '', ext = ''):
+    for each in base_name_list:
+        if not os.path.exists (os.path.join (dir, each + ext)):
+            return False
+    return True
+
+def get_openssl_path ():
+    if os.name == 'nt':
+        if 'OPENSSL_PATH' not in os.environ:
+            os.environ['OPENSSL_PATH'] = "C:\\Openssl\\"
+        if 'OPENSSL_CONF' not in os.environ:
+            openssl_cfg = "C:\\Openssl\\openssl.cfg"
+            if os.path.exists(openssl_cfg):
+                os.environ['OPENSSL_CONF'] = openssl_cfg
+    openssl = os.path.join(os.environ.get ('OPENSSL_PATH', ''), 'openssl')
+    return openssl
+
+def run_process (arg_list, print_cmd = False, capture_out = False):
+    sys.stdout.flush()
+    if print_cmd:
+        print (' '.join(arg_list))
+
+    exc    = None
+    result = 0
+    output = ''
+    try:
+        if capture_out:
+            output = subprocess.check_output(arg_list).decode()
+        else:
+            result = subprocess.call (arg_list)
+    except Exception as ex:
+        result = 1
+        exc    = ex
+
+    if result:
+        if not print_cmd:
+            print ('Error in running process:\n  %s' % ' '.join(arg_list))
+        if exc is None:
+            sys.exit(1)
+        else:
+            raise exc
+
+    return output
diff --git a/IntelFsp2Pkg/Tools/GenCfgData.py b/IntelFsp2Pkg/Tools/GenCfgData.py
new file mode 100644
index 0000000000..384516480d
--- /dev/null
+++ b/IntelFsp2Pkg/Tools/GenCfgData.py
@@ -0,0 +1,2021 @@
+## @ GenCfgData.py
+#
+# Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+import os
+import sys
+import re
+import struct
+import marshal
+import pprint
+import string
+import operator as op
+import ast
+import binascii
+from   datetime    import date
+from   collections import OrderedDict
+
+from CommonUtility import *
+
+# Generated file copyright header
+__copyright_tmp__ = """/** @file
+
+  Platform Configuration %s File.
+
+  Copyright (c) %4d, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+  This file is automatically generated. Please do NOT modify !!!
+
+**/
+"""
+
+def get_copyright_header (file_type, allow_modify = False):
+    file_description = {
+        'yaml': 'Boot Setting',
+        'dlt' : 'Delta',
+        'inc' : 'C Binary Blob',
+        'h'   : 'C Struct Header'
+    }
+    if file_type in ['yaml', 'dlt']:
+        comment_char = '#'
+    else:
+        comment_char = ''
+    lines = __copyright_tmp__.split('\n')
+    if allow_modify:
+      lines = [line for line in lines if 'Please do NOT modify' not in line]
+    copyright_hdr = '\n'.join('%s%s' % (comment_char, line) for line in lines)[:-1] + '\n'
+    return copyright_hdr % (file_description[file_type], date.today().year)
+
+def check_quote (text):
+    if (text[0] == "'" and text[-1] == "'") or (text[0] == '"' and text[-1] == '"'):
+        return True
+    return False
+
+def strip_quote (text):
+    new_text = text.strip()
+    if check_quote (new_text):
+        return new_text[1:-1]
+    return text
+
+def strip_delimiter (text, delim):
+    new_text = text.strip()
+    if new_text:
+        if new_text[0] == delim[0] and new_text[-1] == delim[-1]:
+            return new_text[1:-1]
+    return text
+
+def bytes_to_bracket_str (bytes):
+    return '{ %s }' % (', '.join('0x%02x' % i for i in bytes))
+
+def array_str_to_value (val_str):
+    val_str = val_str.strip()
+    val_str = strip_delimiter (val_str, '{}')
+    val_str = strip_quote (val_str)
+    value = 0
+    for each in val_str.split(',')[::-1]:
+        each = each.strip()
+        value = (value << 8) | int(each, 0)
+    return value
+
+def write_lines (lines, file):
+    fo = open(file, "w")
+    fo.write (''.join ([x[0] for x in lines]))
+    fo.close ()
+
+def read_lines (file):
+    if not os.path.exists(file):
+        test_file = os.path.basename(file)
+        if os.path.exists(test_file):
+            file = test_file
+    fi = open (file, 'r')
+    lines = fi.readlines ()
+    fi.close ()
+    return lines
+
+def expand_file_value (path, value_str):
+    result = bytearray()
+    match  = re.match("\{\s*FILE:(.+)\}", value_str)
+    if match:
+        file_list = match.group(1).split(',')
+        for file in file_list:
+            file = file.strip()
+            bin_path = os.path.join(path, file)
+            result.extend(bytearray(open(bin_path, 'rb').read()))
+    return result
+
+class ExpressionEval(ast.NodeVisitor):
+    operators = {
+        ast.Add:    op.add,
+        ast.Sub:    op.sub,
+        ast.Mult:   op.mul,
+        ast.Div:    op.floordiv,
+        ast.Mod:    op.mod,
+        ast.Eq:     op.eq,
+        ast.NotEq:  op.ne,
+        ast.Gt:     op.gt,
+        ast.Lt:     op.lt,
+        ast.GtE:    op.ge,
+        ast.LtE:    op.le,
+        ast.BitXor: op.xor,
+        ast.BitAnd: op.and_,
+        ast.BitOr:  op.or_,
+        ast.Invert: op.invert,
+        ast.USub:   op.neg
+    }
+
+
+    def __init__(self):
+        self._debug = False
+        self._expression = ''
+        self._namespace = {}
+        self._get_variable = None
+
+    def eval(self, expr, vars={}):
+        self._expression = expr
+        if type(vars) is dict:
+            self._namespace    = vars
+            self._get_variable = None
+        else:
+            self._namespace = {}
+            self._get_variable = vars
+        node = ast.parse(self._expression, mode='eval')
+        result = self.visit(node.body)
+        if self._debug:
+            print ('EVAL [ %s ] = %s' % (expr, str(result)))
+        return result
+
+    def visit_Name(self, node):
+        if self._get_variable is not None:
+            return self._get_variable(node.id)
+        else:
+            return self._namespace[node.id]
+
+    def visit_Num(self, node):
+        return node.n
+
+    def visit_NameConstant(self, node):
+        return node.value
+
+    def visit_BoolOp(self, node):
+        result = False
+        if isinstance(node.op, ast.And):
+            for value in node.values:
+                result = self.visit(value)
+                if not result:
+                    break
+        elif isinstance(node.op, ast.Or):
+            for value in node.values:
+                result = self.visit(value)
+                if result:
+                    break
+        return True if result else False
+
+    def visit_UnaryOp(self, node):
+        val = self.visit(node.operand)
+        return operators[type(node.op)](val)
+
+    def visit_BinOp(self, node):
+        lhs = self.visit(node.left)
+        rhs = self.visit(node.right)
+        return ExpressionEval.operators[type(node.op)](lhs, rhs)
+
+    def visit_Compare(self, node):
+        right = self.visit(node.left)
+        result = True
+        for operation, comp in zip(node.ops, node.comparators):
+            if not result:
+                break
+            left = right
+            right = self.visit(comp)
+            result = ExpressionEval.operators[type(operation)](left, right)
+        return result
+
+    def visit_Call(self, node):
+        if node.func.id in ['ternary']:
+            condition = self.visit (node.args[0])
+            val_true  = self.visit (node.args[1])
+            val_false = self.visit (node.args[2])
+            return val_true if condition else val_false
+        elif node.func.id in ['offset', 'length']:
+            if self._get_variable is not None:
+                return self._get_variable(node.args[0].s, node.func.id)
+        else:
+            raise ValueError("Unsupported function: " + repr(node))
+
+    def generic_visit(self, node):
+        raise ValueError("malformed node or string: " + repr(node))
+
+
+class CFG_YAML():
+    TEMPLATE = 'template'
+    CONFIGS  = 'configs'
+    VARIABLE = 'variable'
+
+    def __init__ (self):
+        self.log_line        = False
+        self.allow_template  = False
+        self.cfg_tree        = None
+        self.tmp_tree        = None
+        self.var_dict        = None
+        self.def_dict        = {}
+        self.yaml_path       = ''
+        self.lines           = []
+        self.full_lines      = []
+        self.index           = 0
+        self.re_expand  = re.compile (r'(.+:\s+|\s*\-\s*)!expand\s+\{\s*(\w+_TMPL)\s*:\s*\[(.+)]\s*\}')
+        self.re_include = re.compile (r'(.+:\s+|\s*\-\s*)!include\s+(.+)')
+
+    @staticmethod
+    def count_indent (line):
+        return next((i for i, c in enumerate(line) if not c.isspace()), len(line))
+
+    @staticmethod
+    def substitue_args (text, arg_dict):
+        for arg in arg_dict:
+            text = text.replace ('$' + arg, arg_dict[arg])
+        return text
+
+    @staticmethod
+    def dprint (*args):
+        pass
+
+    def process_include (self, line, insert = True):
+        match = self.re_include.match (line)
+        if not match:
+            raise Exception ("Invalid !include format '%s' !" % line.strip())
+
+        prefix  = match.group(1)
+        include = match.group(2)
+        if prefix.strip() == '-':
+            prefix = ''
+            adjust = 0
+        else:
+            adjust = 2
+
+        include = strip_quote (include)
+        request = CFG_YAML.count_indent (line) + adjust
+
+        if self.log_line:
+            # remove the include line itself
+            del  self.full_lines[-1]
+
+        inc_path = os.path.join (self.yaml_path, include)
+        if not os.path.exists(inc_path):
+            # try relative path to project root
+            try_path = os.path.join(os.path.dirname (os.path.realpath(__file__)), "../..", include)
+            if os.path.exists(try_path):
+                inc_path = try_path
+            else:
+                raise Exception ("ERROR: Cannot open file '%s'." % inc_path)
+
+        lines = read_lines (inc_path)
+
+        current   = 0
+        same_line = False
+        for idx, each in enumerate (lines):
+            start = each.lstrip()
+            if start == '' or start[0] == '#':
+                continue
+
+            if start[0] == '>':
+                # append the content directly at the same line
+                same_line = True
+
+            start   = idx
+            current = CFG_YAML.count_indent (each)
+            break
+
+        lines = lines[start+1:] if same_line else lines[start:]
+        leading = ''
+        if same_line:
+            request = len(prefix)
+            leading = '>'
+
+        lines = [prefix + '%s\n' % leading] + [' ' * request + i[current:] for i in lines]
+        if insert:
+            self.lines = lines + self.lines
+
+        return lines
+
+    def process_expand (self, line):
+        match = self.re_expand.match(line)
+        if not match:
+            raise Exception ("Invalid !expand format '%s' !" % line.strip())
+        lines      = []
+        prefix     = match.group(1)
+        temp_name  = match.group(2)
+        args       = match.group(3)
+
+        if prefix.strip() == '-':
+            indent = 0
+        else:
+            indent = 2
+        lines      = self.process_expand_template (temp_name, prefix, args, indent)
+        self.lines = lines + self.lines
+
+
+    def process_expand_template (self, temp_name, prefix, args, indent = 2):
+        # expand text with arg substitution
+        if temp_name not in self.tmp_tree:
+            raise Exception ("Could not find template '%s' !" % temp_name)
+        parts = args.split(',')
+        parts = [i.strip() for i in parts]
+        num = len(parts)
+        arg_dict = dict(zip( ['(%d)' % (i + 1) for i in range(num)], parts))
+        str_data = self.tmp_tree[temp_name]
+        text = DefTemplate(str_data).safe_substitute(self.def_dict)
+        text = CFG_YAML.substitue_args (text, arg_dict)
+        target  = CFG_YAML.count_indent (prefix) + indent
+        current = CFG_YAML.count_indent (text)
+        padding = target * ' '
+        if indent == 0:
+            leading = []
+        else:
+            leading = [prefix + '\n']
+        text = leading + [(padding + i + '\n')[current:] for i in text.splitlines()]
+        return text
+
+
+    def load_file (self, yaml_file):
+        self.index  = 0
+        self.lines = read_lines (yaml_file)
+
+
+    def peek_line (self):
+        if len(self.lines) == 0:
+            return None
+        else:
+            return self.lines[0]
+
+
+    def put_line (self, line):
+        self.lines.insert (0, line)
+        if self.log_line:
+            del self.full_lines[-1]
+
+
+    def get_line (self):
+        if len(self.lines) == 0:
+            return None
+        else:
+            line = self.lines.pop(0)
+            if self.log_line:
+                self.full_lines.append (line.rstrip())
+            return line
+
+
+    def get_multiple_line (self, indent):
+        text   = ''
+        newind = indent + 1
+        while True:
+            line   = self.peek_line ()
+            if line is None:
+                break
+            sline = line.strip()
+            if sline != '':
+                newind = CFG_YAML.count_indent(line)
+                if newind <= indent:
+                    break
+            self.get_line ()
+            if sline != '':
+                text = text + line
+        return text
+
+
+    def traverse_cfg_tree (self, handler):
+        def _traverse_cfg_tree (root, level = 0):
+            # config structure
+            for key in root:
+                if type(root[key]) is OrderedDict:
+                    level += 1
+                    handler (key, root[key], level)
+                    _traverse_cfg_tree (root[key], level)
+                    level -= 1
+        _traverse_cfg_tree (self.cfg_tree)
+
+
+    def count (self):
+        def _count (name, cfgs, level):
+            num[0] += 1
+        num = [0]
+        self.traverse_cfg_tree (_count)
+        return  num[0]
+
+
+    def parse (self, parent_name = '', curr = None, level = 0):
+        child = None
+        last_indent = None
+        temp_chk = {}
+
+        while True:
+            line = self.get_line ()
+            if line is None:
+                break
+
+            curr_line = line.strip()
+            if curr_line == '' or curr_line[0] == '#':
+                continue
+
+            indent  = CFG_YAML.count_indent(line)
+            if last_indent is None:
+                last_indent = indent
+
+            if indent != last_indent:
+                # outside of current block,  put the line back to queue
+                self.put_line (' ' * indent + curr_line)
+
+            if curr_line.endswith (': >'):
+                # multiline marker
+                old_count = len(self.full_lines)
+                line = self.get_multiple_line (indent)
+                if self.log_line and not self.allow_template and '!include ' in line:
+                    # expand include in template
+                    new_lines = []
+                    lines = line.splitlines()
+                    for idx, each in enumerate(lines):
+                        if '!include ' in each:
+                            new_line = ''.join(self.process_include (each, False))
+                            new_lines.append(new_line)
+                        else:
+                            new_lines.append(each)
+                    self.full_lines = self.full_lines[:old_count] + new_lines
+                curr_line = curr_line  + line
+
+            if indent > last_indent:
+                # child nodes
+                if child is None:
+                    raise Exception ('Unexpected format at line: %s' % (curr_line))
+
+                level += 1
+                self.parse (key, child, level)
+                level -= 1
+
+                line = self.peek_line ()
+                if line is not None:
+                    curr_line = line.strip()
+                    indent  = CFG_YAML.count_indent(line)
+                    if indent >= last_indent:
+                        # consume the line
+                        self.get_line ()
+                else:
+                    # end of file
+                    indent = -1
+
+            if curr is None:
+                curr = OrderedDict()
+
+            if indent < last_indent:
+                return curr
+
+            marker1 = curr_line[0]
+            marker2 = curr_line[-1]
+            start = 1 if marker1 == '-' else 0
+            pos = curr_line.find(': ')
+            if pos > 0:
+                child = None
+                key = curr_line[start:pos].strip()
+                if curr_line[pos + 2] == '>':
+                    curr[key] = curr_line[pos + 3:]
+                else:
+                    # XXXX: !include / !expand
+                    if '!include ' in curr_line:
+                        self.process_include (line)
+                    elif '!expand ' in curr_line:
+                        if self.allow_template and not self.log_line:
+                            self.process_expand (line)
+                    else:
+                        value_str = curr_line[pos + 2:].strip()
+                        curr[key] = value_str
+                        if self.log_line and value_str[0] == '{':
+                            # expand {FILE: xxxx} format in the log line
+                            if value_str[1:].rstrip().startswith('FILE:'):
+                                value_bytes = expand_file_value (self.yaml_path, value_str)
+                                value_str = bytes_to_bracket_str (value_bytes)
+                                self.full_lines[-1] = line[:indent] + curr_line[:pos + 2] + value_str
+
+            elif marker2 == ':':
+                child = OrderedDict()
+                key = curr_line[start:-1].strip()
+                if key == '$ACTION':
+                    # special virtual nodes, rename to ensure unique key
+                    key = '$ACTION_%04X' % self.index
+                    self.index += 1
+                if key in curr:
+                    if key not in temp_chk:
+                        # check for duplicated keys at same level
+                        temp_chk[key] = 1
+                    else:
+                        #raise Exception ("Duplicated item '%s:%s' found !" % (parent_name, key))
+                        pass
+
+                curr[key] = child
+                if self.var_dict is None and key == CFG_YAML.VARIABLE:
+                    self.var_dict = child
+                if self.tmp_tree is None and key == CFG_YAML.TEMPLATE:
+                    self.tmp_tree = child
+                    if self.var_dict:
+                        for each in self.var_dict:
+                            txt = self.var_dict[each]
+                            if type(txt) is str:
+                                self.def_dict['(%s)' % each] = txt
+                if self.tmp_tree and key == CFG_YAML.CONFIGS:
+                    # apply template for the main configs
+                    self.allow_template = True
+            else:
+                child = None
+                # - !include cfg_opt.yaml
+                if '!include ' in curr_line:
+                    self.process_include (line)
+
+        return curr
+
+
+    def load_yaml (self, opt_file):
+        self.var_dict  = None
+        self.yaml_path = os.path.dirname (opt_file)
+        self.load_file (opt_file)
+        yaml_tree     = self.parse ()
+        self.tmp_tree = yaml_tree[CFG_YAML.TEMPLATE]
+        self.cfg_tree = yaml_tree[CFG_YAML.CONFIGS]
+        return self.cfg_tree
+
+
+    def expand_yaml (self, opt_file):
+        self.log_line = True
+        self.load_yaml (opt_file)
+        self.log_line = False
+        text = '\n'.join (self.full_lines)
+        self.full_lines = []
+        return text
+
+
+class DefTemplate(string.Template):
+    idpattern = '\([_A-Z][_A-Z0-9]*\)|[_A-Z][_A-Z0-9]*'
+
+
+class CGenCfgData:
+    STRUCT         = '$STRUCT'
+    bits_width     = {'b':1, 'B':8, 'W':16, 'D':32, 'Q':64}
+    builtin_option = {'$EN_DIS' : [('0', 'Disable'), ('1', 'Enable')]}
+    exclude_struct = ['FSP_UPD_HEADER', 'FSPT_ARCH_UPD', 'FSPM_ARCH_UPD', 'FSPS_ARCH_UPD'
+                      'GPIO_GPP_*', 'GPIO_CFG_DATA', 'GpioConfPad*',  'GpioPinConfig',
+                      'BOOT_OPTION*', 'PLATFORMID_CFG_DATA', '\w+_Half[01]']
+    include_tag    = ['GPIO_CFG_DATA']
+    keyword_set    = set(['name', 'type', 'option', 'help', 'length', 'value', 'order', 'struct', 'condition'])
+
+    def __init__(self):
+        self.initialize ()
+
+
+    def initialize (self):
+        self._cfg_tree  = {}
+        self._tmp_tree  = {}
+        self._cfg_list  = []
+        self._cfg_page  = {'root': {'title': '', 'child': []}}
+        self._cur_page  = ''
+        self._var_dict  = {}
+        self._def_dict  = {}
+        self._yaml_path = ''
+
+
+    @staticmethod
+    def deep_convert_dict (layer):
+        # convert OrderedDict to list + dict
+        new_list = layer
+        if isinstance(layer, OrderedDict):
+            new_list = list (layer.items())
+            for idx, pair in enumerate (new_list):
+                new_node = CGenCfgData.deep_convert_dict (pair[1])
+                new_list[idx] = dict({pair[0] : new_node})
+        return new_list
+
+
+    @staticmethod
+    def deep_convert_list (layer):
+        if isinstance(layer, list):
+            od = OrderedDict({})
+            for each in layer:
+                if isinstance(each, dict):
+                    key = next(iter(each))
+                    od[key] = CGenCfgData.deep_convert_list(each[key])
+            return od
+        else:
+            return layer
+
+
+    @staticmethod
+    def expand_include_files (file_path, cur_dir = ''):
+        if cur_dir == '':
+            cur_dir   = os.path.dirname(file_path)
+            file_path = os.path.basename(file_path)
+
+        input_file_path = os.path.join(cur_dir, file_path)
+        file  = open(input_file_path, "r")
+        lines = file.readlines()
+        file.close()
+
+        new_lines = []
+        for line_num, line in enumerate(lines):
+            match = re.match("^!include\s*(.+)?$", line.strip())
+            if match:
+                inc_path = match.group(1)
+                tmp_path = os.path.join(cur_dir, inc_path)
+                org_path = tmp_path
+                if not os.path.exists(tmp_path):
+                    cur_dir = os.path.join(os.path.dirname (os.path.realpath(__file__)), "..", "..")
+                tmp_path = os.path.join(cur_dir, inc_path)
+                if not os.path.exists(tmp_path):
+                    raise Exception ("ERROR: Cannot open include file '%s'." % org_path)
+                else:
+                    new_lines.append (('# Included from file: %s\n' % inc_path, tmp_path, 0))
+                    new_lines.append (('# %s\n' % ('=' * 80), tmp_path, 0))
+                    new_lines.extend (CGenCfgData.expand_include_files (inc_path, cur_dir))
+            else:
+                new_lines.append ((line, input_file_path, line_num))
+
+        return new_lines
+
+
+    @staticmethod
+    def format_struct_field_name (input, count = 0):
+        name = ''
+        cap  = True
+        if '_' in input:
+            input = input.lower()
+        for idx, each in enumerate(input):
+          if each == '_':
+              cap = True
+              continue
+          elif cap:
+              if not (len(input) > idx+1 and input[idx+1] == '_'):
+                  each = each.upper()
+              cap  = False
+          name = name + each
+
+        if count > 1:
+            name = '%s[%d]' % (name, count)
+
+        return name
+
+    def get_last_error (self):
+        return ''
+
+
+    def get_variable (self, var, attr = 'value'):
+        if var in self._var_dict:
+            var = self._var_dict[var]
+            return var
+
+        item = self.locate_cfg_item (var, False)
+        if item is None:
+            raise ValueError ("Cannot find variable '%s' !" % var)
+
+        if item:
+            if 'indx' in item:
+                item = self.get_item_by_index (item['indx'])
+            if attr == 'offset':
+                var  = item['offset']
+            elif attr == 'length':
+                var  = item['length']
+            elif attr == 'value':
+                var  = self.get_cfg_item_value (item)
+            else:
+                raise ValueError ("Unsupported variable attribute '%s' !" % attr)
+        return var
+
+
+    def eval (self, expr):
+        def _handler (pattern):
+            if pattern.group(1):
+                target = 1
+            else:
+                target = 2
+            result = self.get_variable(pattern.group(target))
+            if result is None:
+                raise ValueError('Unknown variable $(%s) !' % pattern.group(target))
+            return hex(result)
+
+        expr_eval = ExpressionEval ()
+        if '$' in expr:
+            # replace known variable first
+            expr = re.sub(r'\$\(([_a-zA-Z][\w\.]*)\)|\$([_a-zA-Z][\w\.]*)', _handler, expr)
+        return expr_eval.eval(expr, self.get_variable)
+
+
+    def get_cfg_list (self, page_id = None):
+        if page_id is None:
+            # return full list
+            return self._cfg_list
+        else:
+            # build a new list for items under a page ID
+            cfgs =  [i for i in self._cfg_list if i['cname'] and (i['page'] == page_id)]
+            return cfgs
+
+
+    def get_cfg_page (self):
+        return self._cfg_page
+
+    def get_cfg_item_length (self, item):
+        return item['length']
+
+    def get_cfg_item_value (self, item, array = False):
+        value_str = item['value']
+        length    = item['length']
+        return  self.get_value (value_str, length, array)
+
+
+    def format_value_to_str (self, value, bit_length, old_value = ''):
+        # value is always int
+        length    = (bit_length + 7) // 8
+        fmt = ''
+        if old_value.startswith ('0x'):
+            fmt = '0x'
+        elif old_value and (old_value[0] in ['"', "'", '{']):
+            fmt = old_value[0]
+        else:
+            fmt = ''
+
+        bvalue = value_to_bytearray (value, length)
+        if fmt in ['"', "'"]:
+            svalue = bvalue.rstrip(b'\x00').decode()
+            value_str = fmt + svalue + fmt
+        elif fmt == "{":
+            value_str = '{ ' + ', '.join(['0x%02x' % i for i in bvalue]) + ' }'
+        elif fmt == '0x':
+            hex_len = length * 2
+            if len(old_value) == hex_len + 2:
+                fstr = '0x%%0%dX' % hex_len
+            else:
+                fstr = '0x%X'
+            value_str = fstr % value
+        else:
+            if length <= 2:
+                value_str = '%d'   % value
+            elif length <= 8:
+                value_str = '0x%x' % value
+            else:
+                value_str = '{ ' + ', '.join(['0x%02x' % i for i in bvalue]) + ' }'
+        return value_str
+
+
+    def reformat_value_str (self, value_str, bit_length, old_value = None):
+        value = self.parse_value (value_str, bit_length, False)
+        if old_value is None:
+            old_value = value_str
+        new_value = self.format_value_to_str (value, bit_length, old_value)
+        return new_value
+
+
+    def get_value (self, value_str, bit_length, array = True):
+        value_str = value_str.strip()
+        if value_str[0] == "'" and value_str[-1] == "'" or \
+           value_str[0] == '"' and value_str[-1] == '"':
+            value_str = value_str[1:-1]
+            bvalue = bytearray (value_str.encode())
+            if len(bvalue) == 0:
+                bvalue = bytearray(b'\x00')
+            if array:
+                return  bvalue
+            else:
+                return  bytes_to_value (bvalue)
+        else:
+            if value_str[0] in '{' :
+                value_str = value_str[1:-1].strip()
+            value = 0
+            for each in value_str.split(',')[::-1]:
+                each = each.strip()
+                value = (value << 8) | int(each, 0)
+            if array:
+                length = (bit_length + 7) // 8
+                return value_to_bytearray (value, length)
+            else:
+                return value
+
+
+    def parse_value (self, value_str, bit_length, array = True):
+        length = (bit_length + 7) // 8
+        if check_quote(value_str):
+            value_str = bytes_to_bracket_str(value_str[1:-1].encode())
+        elif (',' in value_str) and (value_str[0] != '{'):
+            value_str = '{ %s }' % value_str
+        if value_str[0] == '{':
+            result = expand_file_value (self._yaml_path, value_str)
+            if len(result) == 0 :
+                bin_list = value_str[1:-1].split(',')
+                value            = 0
+                bit_len          = 0
+                unit_len         = 1
+                for idx, element in enumerate(bin_list):
+                    each = element.strip()
+                    if len(each) == 0:
+                        continue
+
+                    in_bit_field = False
+                    if each[0] in "'" + '"':
+                        each_value = bytearray(each[1:-1], 'utf-8')
+                    elif ':' in each:
+                        match    = re.match("^(.+):(\d+)([b|B|W|D|Q])$", each)
+                        if match is None:
+                            raise SystemExit("Exception: Invald value list format '%s' !" % each)
+                        if match.group(1) == '0' and match.group(2) == '0':
+                            unit_len = CGenCfgData.bits_width[match.group(3)] // 8
+                        cur_bit_len = int(match.group(2)) * CGenCfgData.bits_width[match.group(3)]
+                        value   += ((self.eval(match.group(1)) & (1<<cur_bit_len) - 1)) << bit_len
+                        bit_len += cur_bit_len
+                        each_value = bytearray()
+                        if idx + 1 < len(bin_list):
+                            in_bit_field = True
+                    else:
+                        try:
+                            each_value = value_to_bytearray(self.eval(each.strip()), unit_len)
+                        except:
+                            raise SystemExit("Exception: Value cannot fit into %s bytes !" % (each, unit_len))
+
+                    if not in_bit_field:
+                        if bit_len > 0:
+                            if bit_len % 8 != 0:
+                                raise SystemExit("Exception: Invalid bit field alignment '%s' !" % value_str)
+                            result.extend(value_to_bytes(value, bit_len // 8))
+                        value   = 0
+                        bit_len = 0
+
+                    result.extend(each_value)
+
+        elif check_quote (value_str):
+            result = bytearray(value_str[1:-1], 'utf-8')  # Excluding quotes
+        else:
+            result = value_to_bytearray (self.eval(value_str), length)
+
+        if len(result) < length:
+            result.extend(b'\x00' * (length - len(result)))
+        elif len(result) > length:
+            raise SystemExit ("Exception: Value '%s' is too big to fit into %d bytes !" % (value_str, length))
+
+        if array:
+            return result
+        else:
+            return bytes_to_value(result)
+
+        return result
+
+
+    def get_cfg_item_options (self, item):
+        tmp_list = []
+        if  item['type'] == "Combo":
+            if item['option'] in CGenCfgData.builtin_option:
+                for op_val, op_str in CGenCfgData.builtin_option[item['option']]:
+                    tmp_list.append((op_val, op_str))
+            else:
+                opt_list = item['option'].split(',')
+                for option in opt_list:
+                    option = option.strip()
+                    try:
+                        (op_val, op_str) = option.split(':')
+                    except:
+                        raise SystemExit ("Exception: Invalide option format '%s' !" % option)
+                    tmp_list.append((op_val, op_str))
+        return  tmp_list
+
+
+    def get_page_title(self, page_id, top = None):
+        if top is None:
+            top = self.get_cfg_page()['root']
+        for node in top['child']:
+            page_key = next(iter(node))
+            if page_id == page_key:
+                return node[page_key]['title']
+            else:
+                result = self.get_page_title (page_id, node[page_key])
+                if result is not None:
+                    return result
+        return None
+
+
+    def print_pages(self, top=None, level=0):
+        if top is None:
+            top = self.get_cfg_page()['root']
+        for node in top['child']:
+            page_id = next(iter(node))
+            print('%s%s: %s' % ('  ' * level, page_id, node[page_id]['title']))
+            level += 1
+            self.print_pages(node[page_id], level)
+            level -= 1
+
+
+    def get_item_by_index (self, index):
+        return self._cfg_list[index]
+
+
+    def get_item_by_path (self, path):
+        node = self.locate_cfg_item (path)
+        if node:
+            return self.get_item_by_index (node['indx'])
+        else:
+            return None
+
+    def locate_cfg_path (self, item):
+        def _locate_cfg_path (root, level = 0):
+            # config structure
+            if item is root:
+                return path
+            for key in root:
+                if type(root[key]) is OrderedDict:
+                    level += 1
+                    path.append(key)
+                    ret = _locate_cfg_path (root[key], level)
+                    if ret:
+                        return ret
+                    path.pop()
+            return None
+        path = []
+        return _locate_cfg_path (self._cfg_tree)
+
+
+    def locate_cfg_item (self, path, allow_exp = True):
+        def _locate_cfg_item (root, path, level = 0):
+            if len(path) == level:
+                return root
+            next_root = root.get(path[level], None)
+            if next_root is None:
+                if allow_exp:
+                    raise Exception ('Not a valid CFG config option path: %s' % '.'.join(path[:level+1]))
+                else:
+                    return None
+            return _locate_cfg_item (next_root, path, level + 1)
+
+        path_nodes = path.split('.')
+        return _locate_cfg_item (self._cfg_tree, path_nodes)
+
+
+    def traverse_cfg_tree (self, handler, top = None):
+        def _traverse_cfg_tree (root, level = 0):
+            # config structure
+            for key in root:
+                if type(root[key]) is OrderedDict:
+                    level += 1
+                    handler (key, root[key], level)
+                    _traverse_cfg_tree (root[key], level)
+                    level -= 1
+
+        if top is None:
+            top = self._cfg_tree
+        _traverse_cfg_tree (top)
+
+
+    def print_cfgs(self, root = None, short = True, print_level = 256):
+        def _print_cfgs (name, cfgs, level):
+
+            if 'indx' in cfgs:
+                act_cfg = self.get_item_by_index (cfgs['indx'])
+            else:
+                offset = 0
+                length = 0
+                value  = ''
+                path=''
+                if CGenCfgData.STRUCT in cfgs:
+                    cfg = cfgs[CGenCfgData.STRUCT]
+                    offset = int(cfg['offset'])
+                    length = int(cfg['length'])
+                    if 'value' in cfg:
+                        value = cfg['value']
+                if length == 0:
+                    return
+                act_cfg = dict({'value' : value, 'offset' : offset, 'length' : length})
+            value   = act_cfg['value']
+            bit_len = act_cfg['length']
+            offset  = (act_cfg['offset'] + 7) // 8
+            if value != '':
+                try:
+                    value = self.reformat_value_str (act_cfg['value'], act_cfg['length'])
+                except:
+                    value = act_cfg['value']
+            length  = bit_len // 8
+            bit_len = '(%db)' % bit_len if bit_len % 8 else '' * 4
+            if level <= print_level:
+                if short and len(value) > 40:
+                    value = '%s ... %s' % (value[:20] , value[-20:])
+                print('%04X:%04X%-6s %s%s : %s' % (offset, length, bit_len, '  ' * level, name, value))
+
+        self.traverse_cfg_tree (_print_cfgs)
+
+
+    def build_var_dict (self):
+        def _build_var_dict (name, cfgs, level):
+            if level <= 2:
+                if CGenCfgData.STRUCT in cfgs:
+                    struct_info = cfgs[CGenCfgData.STRUCT]
+                    self._var_dict['_LENGTH_%s_' % name] = struct_info['length'] // 8
+                    self._var_dict['_OFFSET_%s_' % name] = struct_info['offset'] // 8
+
+        self._var_dict  = {}
+        self.traverse_cfg_tree (_build_var_dict)
+        self._var_dict['_LENGTH_'] = self._cfg_tree[CGenCfgData.STRUCT]['length'] // 8
+        return 0
+
+
+    def add_cfg_page(self, child, parent, title=''):
+        def _add_cfg_page(cfg_page, child, parent):
+            key = next(iter(cfg_page))
+            if parent == key:
+                cfg_page[key]['child'].append({child: {'title': title,
+                                                       'child': []}})
+                return True
+            else:
+                result = False
+                for each in cfg_page[key]['child']:
+                    if _add_cfg_page(each, child, parent):
+                        result = True
+                        break
+                return result
+
+        return _add_cfg_page(self._cfg_page, child, parent)
+
+
+    def set_cur_page(self, page_str):
+        if not page_str:
+            return
+
+        if ',' in page_str:
+            page_list = page_str.split(',')
+        else:
+            page_list = [page_str]
+        for page_str in page_list:
+            parts = page_str.split(':')
+            if len(parts) in [1, 3]:
+                page = parts[0].strip()
+                if len(parts) == 3:
+                    # it is a new page definition, add it into tree
+                    parent = parts[1] if parts[1] else 'root'
+                    parent = parent.strip()
+                    if parts[2][0] == '"' and parts[2][-1] == '"':
+                        parts[2] = parts[2][1:-1]
+
+                    if not self.add_cfg_page(page, parent, parts[2]):
+                        raise SystemExit("Error: Cannot find parent page '%s'!" % parent)
+            else:
+                raise SystemExit("Error: Invalid page format '%s' !" % page_str)
+            self._cur_page = page
+
+
+    def extend_variable (self, line):
+        # replace all variables
+        if line == '':
+            return line
+        loop = 2
+        while loop > 0:
+            line_after = DefTemplate(line).safe_substitute(self._def_dict)
+            if line == line_after:
+                break
+            loop -= 1
+            line = line_after
+        return line_after
+
+    def reformat_number_per_type (self, itype, value):
+        if check_quote(value) or value.startswith('{'):
+            return value
+        parts = itype.split(',')
+        if len(parts) > 3 and parts[0] == 'EditNum':
+            num_fmt = parts[1].strip()
+        else:
+            num_fmt = ''
+        if num_fmt == 'HEX' and not value.startswith('0x'):
+            value = '0x%X' % int(value, 10)
+        elif num_fmt == 'DEC' and value.startswith('0x'):
+            value = '%d' % int(value, 16)
+        return value
+
+    def add_cfg_item(self, name, item, offset, path):
+
+        self.set_cur_page (item.get('page', ''))
+
+        if name[0] == '$':
+            # skip all virtual node
+            return 0
+
+
+        if not set(item).issubset(CGenCfgData.keyword_set):
+            for each in list(item):
+                if each not in CGenCfgData.keyword_set:
+                    raise Exception ("Invalid attribute '%s' for '%s'!" % (each, '.'.join(path)))
+
+        length = item.get('length', 0)
+        if type(length) is str:
+            match = re.match("^(\d+)([b|B|W|D|Q])([B|W|D|Q]?)\s*$", length)
+            if match:
+                unit_len = CGenCfgData.bits_width[match.group(2)]
+                length = int(match.group(1), 10) * unit_len
+            else:
+                try:
+                    length = int(length, 0) * 8
+                except:
+                    raise Exception ("Invalid length field '%s' for '%s' !" % (length, '.'.join(path)))
+
+                if offset % 8 > 0:
+                    raise Exception ("Invalid alignment for field '%s' for '%s' !" % (name, '.'.join(path)))
+        else:
+            # define is length in bytes
+            length = length * 8
+
+        if not name.isidentifier():
+            raise Exception ("Invalid config name '%s' for '%s' !" % (name, '.'.join(path)))
+
+
+        itype = str(item.get('type', 'Reserved'))
+        value = str(item.get('value', ''))
+        if value:
+            if not (check_quote(value) or value.startswith('{')):
+                if ',' in value:
+                    value = '{ %s }' % value
+                else:
+                    value = self.reformat_number_per_type (itype, value)
+
+        help = str(item.get('help', ''))
+        if '\n' in help:
+            help = ' '.join ([i.strip() for i in help.splitlines()])
+
+        option = str(item.get('option', ''))
+        if '\n' in option:
+            option = ' '.join ([i.strip() for i in option.splitlines()])
+
+        # extend variables for value and condition
+        condition = str(item.get('condition', ''))
+        if condition:
+            condition = self.extend_variable (condition)
+        value     = self.extend_variable (value)
+
+        order = str(item.get('order', ''))
+        if order:
+            if '.' in order:
+                (major, minor) = order.split('.')
+                order = int (major, 16)
+            else:
+                order = int (order, 16)
+        else:
+            order = offset
+
+        cfg_item = dict()
+        cfg_item['length'] = length
+        cfg_item['offset'] = offset
+        cfg_item['value']  = value
+        cfg_item['type']   = itype
+        cfg_item['cname']  = str(name)
+        cfg_item['name']   = str(item.get('name', ''))
+        cfg_item['help']   = help
+        cfg_item['option'] = option
+        cfg_item['page']   = self._cur_page
+        cfg_item['order']  = order
+        cfg_item['path']   = '.'.join(path)
+        cfg_item['condition']  = condition
+        if 'struct' in item:
+            cfg_item['struct'] = item['struct']
+        self._cfg_list.append(cfg_item)
+
+        item['indx']       = len(self._cfg_list) - 1
+
+        # remove used info for reducing pkl size
+        item.pop('option', None)
+        item.pop('condition', None)
+        item.pop('help', None)
+        item.pop('name', None)
+        item.pop('page', None)
+
+        return length
+
+
+    def build_cfg_list (self, cfg_name ='', top = None, path = [], info = {'offset': 0}):
+        if top is None:
+            top = self._cfg_tree
+
+        start = info['offset']
+        is_leaf = True
+        for key in top:
+            path.append(key)
+            if type(top[key]) is OrderedDict:
+                is_leaf = False
+                self.build_cfg_list(key, top[key], path, info)
+            path.pop()
+
+        if is_leaf:
+            length = self.add_cfg_item(cfg_name, top, info['offset'], path)
+            info['offset'] += length
+        elif cfg_name == '' or (cfg_name and cfg_name[0] != '$'):
+            # check first element for struct
+            first = next(iter(top))
+            struct_str = CGenCfgData.STRUCT
+            if first != struct_str:
+                struct_node = OrderedDict({})
+                top[struct_str] = struct_node
+                top.move_to_end (struct_str, False)
+            else:
+                struct_node = top[struct_str]
+            struct_node['offset'] = start
+            struct_node['length'] = info['offset'] - start
+            if struct_node['length'] % 8 != 0:
+                raise SystemExit("Error: Bits length not aligned for %s !" % str(path))
+
+
+    def get_field_value (self, top = None):
+        def _get_field_value (name, cfgs, level):
+            if 'indx' in cfgs:
+                act_cfg = self.get_item_by_index (cfgs['indx'])
+                if act_cfg['length'] == 0:
+                    return
+                value = self.get_value (act_cfg['value'], act_cfg['length'], False)
+                set_bits_to_bytes (result, act_cfg['offset'] - struct_info['offset'], act_cfg['length'], value)
+
+        if top is None:
+            top = self._cfg_tree
+        struct_info = top[CGenCfgData.STRUCT]
+        result = bytearray ((struct_info['length'] + 7) // 8)
+        self.traverse_cfg_tree (_get_field_value, top)
+        return  result
+
+
+    def set_field_value (self, top, value_bytes, force = False):
+        def _set_field_value (name, cfgs, level):
+            if 'indx' not in cfgs:
+                return
+            act_cfg = self.get_item_by_index (cfgs['indx'])
+            if force or act_cfg['value'] == '':
+                value = get_bits_from_bytes (full_bytes, act_cfg['offset'] - struct_info['offset'], act_cfg['length'])
+                act_val = act_cfg['value']
+                if act_val == '':
+                    act_val = '%d' % value
+                act_val = self.reformat_number_per_type (act_cfg['type'], act_val)
+                act_cfg['value'] = self.format_value_to_str (value, act_cfg['length'], act_val)
+
+        if 'indx' in top:
+            # it is config option
+            value   = bytes_to_value (value_bytes)
+            act_cfg = self.get_item_by_index (top['indx'])
+            act_cfg['value'] = self.format_value_to_str (value, act_cfg['length'], act_cfg['value'])
+        else:
+            # it is structure
+            struct_info = top[CGenCfgData.STRUCT]
+            length = struct_info['length'] // 8
+            full_bytes = bytearray(value_bytes[:length])
+            if len(full_bytes) < length:
+                full_bytes.extend(bytearray(length - len(value_bytes)))
+            self.traverse_cfg_tree (_set_field_value, top)
+
+
+    def update_def_value (self):
+        def _update_def_value (name, cfgs, level):
+            if 'indx' in cfgs:
+                act_cfg = self.get_item_by_index (cfgs['indx'])
+                if act_cfg['value'] != '' and act_cfg['length'] > 0:
+                    try:
+                        act_cfg['value'] = self.reformat_value_str (act_cfg['value'], act_cfg['length'])
+                    except:
+                        raise Exception ("Invalid value expression '%s' for '%s' !" % (act_cfg['value'], act_cfg['path']))
+            else:
+                if CGenCfgData.STRUCT in cfgs and 'value' in cfgs[CGenCfgData.STRUCT]:
+                    curr = cfgs[CGenCfgData.STRUCT]
+                    value_bytes = value_to_bytearray (self.eval(curr['value']), (curr['length'] + 7) // 8)
+                    self.set_field_value (cfgs, value_bytes)
+
+        self.traverse_cfg_tree (_update_def_value, self._cfg_tree)
+
+
+    def evaluate_condition (self, item):
+        expr = item['condition']
+        result = self.parse_value (expr, 1, False)
+        return result
+
+
+    def load_default_from_bin (self, bin_data):
+        self.set_field_value(self._cfg_tree, bin_data, True)
+
+
+    def generate_binary_array (self, path = ''):
+        if path == '':
+            top =None
+        else:
+            top  = self.locate_cfg_item (path)
+            if not top:
+                raise Exception("Invalid configuration path '%s' !" % path)
+        return self.get_field_value(top)
+
+    def generate_binary (self, bin_file_name, path = ''):
+        bin_file = open(bin_file_name, "wb")
+        bin_file.write (self.generate_binary_array (path))
+        bin_file.close()
+        return 0
+
+    def write_delta_file (self, out_file, platform_id, out_lines):
+        dlt_fd = open (out_file, "w")
+        dlt_fd.write ("%s\n"   % get_copyright_header('dlt', True))
+        dlt_fd.write ('#\n')
+        dlt_fd.write ('# Delta configuration values for platform ID 0x%04X\n' % platform_id)
+        dlt_fd.write ('#\n\n')
+        for line in out_lines:
+            dlt_fd.write ('%s\n' % line)
+        dlt_fd.close()
+
+
+    def override_default_value(self, dlt_file):
+        error = 0
+        dlt_lines = CGenCfgData.expand_include_files(dlt_file)
+
+        platform_id = None
+        for line, file_path, line_num in dlt_lines:
+            line = line.strip()
+            if not line or line.startswith('#'):
+                continue
+            match = re.match("\s*([\w\.]+)\s*\|\s*(.+)", line)
+            if not match:
+                raise Exception("Unrecognized line '%s' (File:'%s' Line:%d) !" %
+                                (line, file_path, line_num + 1))
+
+            path      = match.group(1)
+            value_str = match.group(2)
+            top  = self.locate_cfg_item (path)
+            if not top:
+                raise Exception(
+                    "Invalid configuration '%s' (File:'%s' Line:%d) !" %
+                    (path, file_path, line_num + 1))
+
+            if 'indx' in top:
+                act_cfg = self.get_item_by_index (top['indx'])
+                bit_len = act_cfg['length']
+            else:
+                struct_info = top[CGenCfgData.STRUCT]
+                bit_len     = struct_info['length']
+
+            value_bytes = self.parse_value (value_str, bit_len)
+            self.set_field_value (top, value_bytes, True)
+
+            if path == 'PLATFORMID_CFG_DATA.PlatformId':
+                platform_id = value_str
+
+        if platform_id is None:
+            raise Exception(
+                "PLATFORMID_CFG_DATA.PlatformId is missing in file '%s' !" %
+                (dlt_file))
+
+        return error
+
+
+    def generate_delta_file_from_bin (self, delta_file, old_data, new_data, full=False):
+        self.load_default_from_bin (new_data)
+        lines = []
+        tag_name = ''
+        level = 0
+        platform_id = None
+        def_platform_id = 0
+
+        for item in self._cfg_list:
+            old_val = get_bits_from_bytes (old_data, item['offset'],  item['length'])
+            new_val = get_bits_from_bytes (new_data, item['offset'],  item['length'])
+
+            full_name = item['path']
+            if 'PLATFORMID_CFG_DATA.PlatformId' == full_name:
+                def_platform_id = old_val
+
+            if new_val != old_val:
+                val_str = self.reformat_value_str (item['value'], item['length'])
+                text = '%-40s | %s' % (full_name, val_str)
+                lines.append(text)
+
+        if platform_id is None or def_platform_id == platform_id:
+            platform_id = def_platform_id
+            # print("WARNING: 'PlatformId' configuration is same as default %d!" % platform_id)
+
+        lines.insert(0, '%-40s | %s\n\n' %
+                     ('PLATFORMID_CFG_DATA.PlatformId', '0x%04X' % platform_id))
+
+        self.write_delta_file (delta_file, platform_id, lines)
+        return 0
+
+
+    def generate_delta_file(self, delta_file, bin_file, bin_file2, full=False):
+        fd = open (bin_file, 'rb')
+        new_data = bytearray(fd.read())
+        fd.close()
+
+        if bin_file2 == '':
+            old_data = self.generate_binary_array()
+        else:
+            old_data = new_data
+            fd = open (bin_file2, 'rb')
+            new_data = bytearray(fd.read())
+            fd.close()
+
+        return self.generate_delta_file_from_bin (delta_file, old_data, new_data, full)
+
+
+    def prepare_marshal (self, is_save):
+        if is_save:
+            # Ordered dict is not marshallable, convert to list
+            self._cfg_tree = CGenCfgData.deep_convert_dict (self._cfg_tree)
+        else:
+            # Revert it back
+            self._cfg_tree = CGenCfgData.deep_convert_list (self._cfg_tree)
+
+    def generate_yml_file (self, in_file, out_file):
+        cfg_yaml = CFG_YAML()
+        text = cfg_yaml.expand_yaml (in_file)
+        yml_fd = open(out_file, "w")
+        yml_fd.write (text)
+        yml_fd.close ()
+        return 0
+
+
+    def write_cfg_header_file (self, hdr_file_name, tag_mode, tag_dict, struct_list):
+        lines = []
+        lines.append ('\n')
+        is_fsp   = True if (tag_mode & 0x80) else False
+        if is_fsp:
+            lines.append ('#include <FspUpd.h>\n')
+
+        tag_mode = tag_mode & 0x7F
+        tag_list = sorted(list(tag_dict.items()), key=lambda x: x[1])
+        for tagname, tagval in tag_list:
+            if (tag_mode == 0 and tagval >= 0x100) or (tag_mode == 1 and tagval < 0x100):
+                continue
+            lines.append ('#define    %-30s 0x%03X\n' % ('CDATA_%s_TAG' % tagname[:-9], tagval))
+
+        lines.append ('\n#pragma pack(1)\n')
+
+        name_dict = {}
+        new_dict  = {}
+        for each in struct_list:
+            if (tag_mode == 0 and each['tag'] >= 0x100) or (tag_mode == 1 and each['tag'] < 0x100):
+                continue
+            new_dict[each['name']]  = (each['alias'], each['count'], each['exclude'])
+            if each['alias'] not in name_dict:
+                name_dict[each['alias']] = 1
+                lines.extend(self.create_struct (each['alias'], each['node'], new_dict))
+
+        lines.append ('#pragma pack()\n\n')
+
+        self.write_header_file (lines, hdr_file_name)
+
+
+    def write_header_file (self, txt_body, file_name, type = 'h'):
+        file_name_def = os.path.basename(file_name).replace ('.', '_')
+        file_name_def = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', file_name_def)
+        file_name_def = re.sub('([a-z0-9])([A-Z])', r'\1_\2', file_name_def).upper()
+
+        lines = []
+        lines.append ("%s\n"   % get_copyright_header(type))
+        lines.append ("#ifndef __%s__\n"   % file_name_def)
+        lines.append ("#define __%s__\n" % file_name_def)
+        lines.extend (txt_body)
+        lines.append ("#endif\n")
+
+        # Don't rewrite if the contents are the same
+        create = True
+        if os.path.exists(file_name):
+            hdr_file  = open(file_name, "r")
+            org_txt   = hdr_file.read()
+            hdr_file.close()
+
+            new_txt   = ''.join(lines)
+            if org_txt == new_txt:
+                create = False
+
+        if create:
+            hdr_file  = open(file_name, "w")
+            hdr_file.write (''.join(lines))
+            hdr_file.close()
+
+
+    def generate_data_inc_file (self, dat_inc_file_name, bin_file = None):
+        # Put a prefix GUID before CFGDATA so that it can be located later on
+        prefix   = b'\xa7\xbd\x7f\x73\x20\x1e\x46\xd6\xbe\x8f\x64\x12\x05\x8d\x0a\xa8'
+        if bin_file:
+            fin = open (bin_file, 'rb')
+            bin_dat = prefix + bytearray(fin.read())
+            fin.close()
+        else:
+            bin_dat = prefix + self.generate_binary_array ()
+
+        file_name = os.path.basename(dat_inc_file_name).upper()
+        file_name = file_name.replace('.', '_')
+
+        txt_lines = []
+
+        txt_lines.append ("UINT8  mConfigDataBlob[%d] = {\n" % len(bin_dat))
+        count = 0
+        line  = ['  ']
+        for each in bin_dat:
+            line.append('0x%02X, ' % each)
+            count = count + 1
+            if (count & 0x0F) == 0:
+                line.append('\n')
+                txt_lines.append (''.join(line))
+                line  = ['  ']
+        if len(line) > 1:
+            txt_lines.append (''.join(line) + '\n')
+
+        txt_lines.append ("};\n\n")
+
+        self.write_header_file (txt_lines, dat_inc_file_name, 'inc')
+
+        return 0
+
+
+    def get_struct_array_info (self, input):
+        parts = input.split(':')
+        if len(parts) > 1:
+           var   = parts[1]
+           input = parts[0]
+        else:
+           var = ''
+        array_str = input.split('[')
+        name     = array_str[0]
+        if len(array_str) > 1:
+            num_str = ''.join(c for c in array_str[-1] if c.isdigit())
+            num_str = '1000' if len(num_str) == 0 else num_str
+            array_num = int(num_str)
+        else:
+            array_num = 0
+        return name, array_num, var
+
+
+    def process_multilines (self, string, max_char_length):
+        multilines = ''
+        string_length = len(string)
+        current_string_start = 0
+        string_offset = 0
+        break_line_dict = []
+        if len(string) <= max_char_length:
+            while (string_offset < string_length):
+                if string_offset >= 1:
+                    if string[string_offset - 1] == '\\' and string[string_offset] == 'n':
+                        break_line_dict.append (string_offset + 1)
+                string_offset += 1
+            if break_line_dict != []:
+                for each in break_line_dict:
+                    multilines += "  %s\n" % string[current_string_start:each].lstrip()
+                    current_string_start = each
+                if string_length - current_string_start > 0:
+                    multilines += "  %s\n" % string[current_string_start:].lstrip()
+            else:
+                multilines = "  %s\n" % string
+        else:
+            new_line_start = 0
+            new_line_count = 0
+            found_space_char = False
+            while (string_offset < string_length):
+                if string_offset >= 1:
+                    if new_line_count >= max_char_length - 1:
+                        if string[string_offset] == ' ' and string_length - string_offset > 10:
+                            break_line_dict.append (new_line_start + new_line_count)
+                            new_line_start = new_line_start + new_line_count
+                            new_line_count = 0
+                            found_space_char = True
+                        elif string_offset == string_length - 1 and found_space_char == False:
+                            break_line_dict.append (0)
+                    if string[string_offset - 1] == '\\' and string[string_offset] == 'n':
+                        break_line_dict.append (string_offset + 1)
+                        new_line_start = string_offset + 1
+                        new_line_count = 0
+                string_offset += 1
+                new_line_count += 1
+            if break_line_dict != []:
+                break_line_dict.sort ()
+                for each in break_line_dict:
+                    if each > 0:
+                        multilines += "  %s\n" % string[current_string_start:each].lstrip()
+                    current_string_start = each
+                if string_length - current_string_start > 0:
+                    multilines += "  %s\n" % string[current_string_start:].lstrip()
+        return multilines
+
+
+    def create_field (self, item, name, length, offset, struct, bsf_name, help, option, bits_length = None):
+        pos_name    = 28
+        pos_comment = 30
+        name_line=''
+        help_line=''
+        option_line=''
+
+        if length == 0 and name == 'dummy':
+            return '\n'
+
+        if bits_length == 0:
+            return '\n'
+
+        is_array = False
+        if length in [1,2,4,8]:
+            type = "UINT%d" % (length * 8)
+        else:
+            is_array = True
+            type = "UINT8"
+
+        if item and item['value'].startswith('{'):
+            type = "UINT8"
+            is_array = True
+
+        if struct != '':
+            struct_base = struct.rstrip('*')
+            name = '*' * (len(struct) - len(struct_base)) + name
+            struct = struct_base
+            type  = struct
+            if struct in ['UINT8','UINT16','UINT32','UINT64']:
+                is_array = True
+                unit = int(type[4:]) // 8
+                length = length / unit
+            else:
+                is_array = False
+
+        if is_array:
+            name = name + '[%d]' % length
+
+        if len(type) < pos_name:
+            space1 = pos_name - len(type)
+        else:
+            space1 = 1
+
+        if bsf_name != '':
+            name_line=" %s\n" % bsf_name
+        else:
+            name_line="N/A\n"
+
+        if help != '':
+            help_line = self.process_multilines (help, 80)
+
+        if option != '':
+            option_line = self.process_multilines (option, 80)
+
+        if offset is None:
+            offset_str = '????'
+        else:
+            offset_str = '0x%04X' % offset
+
+        if bits_length is None:
+            bits_length = ''
+        else:
+            bits_length = ' : %d' % bits_length
+
+        #return "\n/** %s%s%s**/\n  %s%s%s%s;\n" % (name_line, help_line, option_line, type, ' ' * space1, name, bits_length)
+        return "\n  /* Offset %s: %s */\n  %s%s%s%s;\n" % (offset_str, name_line.strip(), type, ' ' * space1, name, bits_length)
+
+
+    def create_struct (self, cname, top, struct_dict):
+        index = 0
+        last  = ''
+        lines = []
+        off_base = -1
+
+        if cname in struct_dict:
+            if struct_dict[cname][2]:
+                return []
+
+        lines.append ('\ntypedef struct {\n')
+        for field in top:
+            if field[0] == '$':
+                continue
+
+            index += 1
+
+            t_item = top[field]
+            if 'indx' not in t_item:
+                if CGenCfgData.STRUCT not in top[field]:
+                    continue
+
+                if struct_dict[field][1] == 0:
+                    continue
+
+                append  = True
+                struct_info = top[field][CGenCfgData.STRUCT]
+
+                if 'struct' in struct_info:
+                    struct, array_num, var = self.get_struct_array_info (struct_info['struct'])
+                    if array_num > 0:
+                        if last == struct:
+                            append  = False
+                            last = struct
+                        if var == '':
+                            var = field
+
+                        field  = CGenCfgData.format_struct_field_name (var, struct_dict[field][1])
+                else:
+                    struct = struct_dict[field][0]
+                    field  = CGenCfgData.format_struct_field_name (field, struct_dict[field][1])
+
+                if append:
+                    line = self.create_field (None, field, 0, 0, struct, '', '', '')
+                    lines.append ('  %s' % line)
+                    last = struct
+                continue
+
+            item   = self.get_item_by_index (t_item['indx'])
+            if item['cname'] == 'CfgHeader' and index == 1  or (item['cname'] == 'CondValue' and index == 2):
+                continue
+
+            bit_length = None
+            length = (item['length'] + 7) // 8
+            match  = re.match("^(\d+)([b|B|W|D|Q])([B|W|D|Q]?)", t_item['length'])
+            if match and match.group(2) == 'b':
+                bit_length = int(match.group(1))
+                if match.group(3) != '':
+                    length = CGenCfgData.bits_width[match.group(3)] // 8
+                else:
+                    length = 4
+            offset = item['offset'] // 8
+            if off_base == -1:
+                off_base = offset
+            struct = item.get('struct', '')
+            name   = field
+            prompt = item['name']
+            help   = item['help']
+            option = item['option']
+            line = self.create_field (item, name, length, offset - off_base, struct, prompt, help, option, bit_length)
+            lines.append ('  %s' % line)
+            last = struct
+
+        lines.append ('\n} %s;\n\n' % cname)
+
+        return lines
+
+    def write_fsp_sig_header_file (self, hdr_file_name):
+        hdr_fd = open (hdr_file_name, 'w')
+        hdr_fd.write ("%s\n"   % get_copyright_header('h'))
+        hdr_fd.write ("#ifndef __FSPUPD_H__\n"
+                      "#define __FSPUPD_H__\n\n"
+                      "#include <FspEas.h>\n\n"
+                      "#pragma pack(1)\n\n")
+        lines = []
+        for fsp_comp in 'TMS':
+            top = self.locate_cfg_item ('FSP%s_UPD' % fsp_comp)
+            if not top:
+                 raise Exception ('Could not find FSP UPD definition !')
+            bins = self.get_field_value(top)
+            lines.append("#define FSP%s_UPD_SIGNATURE    0x%016X  /* '%s' */\n\n" % (fsp_comp, bytes_to_value(bins[:8]), bins[:8].decode()))
+        hdr_fd.write (''.join(lines))
+        hdr_fd.write ("#pragma pack()\n\n"
+                      "#endif\n")
+        hdr_fd.close ()
+
+    def create_header_file (self, hdr_file_name, com_hdr_file_name = '', path = ''):
+        def _build_header_struct (name, cfgs, level):
+            if CGenCfgData.STRUCT in cfgs:
+                if 'CfgHeader' in cfgs:
+                    # collect CFGDATA TAG IDs
+                    cfghdr  = self.get_item_by_index (cfgs['CfgHeader']['indx'])
+                    tag_val = array_str_to_value(cfghdr['value']) >> 20
+                    tag_dict[name] = tag_val
+                    if level == 1:
+                        tag_curr[0] = tag_val
+                struct_dict[name] = (level, tag_curr[0], cfgs)
+
+        if path == 'FSP_SIG':
+            self.write_fsp_sig_header_file (hdr_file_name)
+            return
+
+        tag_curr      = [0]
+        tag_dict      = {}
+        struct_dict   = {}
+
+        if path == '':
+            top = None
+        else:
+            top = self.locate_cfg_item (path)
+            if not top:
+                raise Exception("Invalid configuration path '%s' !" % path)
+            _build_header_struct (path, top, 0)
+        self.traverse_cfg_tree (_build_header_struct, top)
+
+        if tag_curr[0] == 0:
+            hdr_mode = 2
+        else:
+            hdr_mode = 1
+
+        if re.match('FSP[TMS]_UPD', path):
+            hdr_mode |= 0x80
+
+        # filter out the items to be built for tags and structures
+        struct_list = []
+        for each in struct_dict:
+            match = False
+            for check in CGenCfgData.exclude_struct:
+                if re.match (check, each):
+                    match = True
+                    if each in tag_dict:
+                        if each not in CGenCfgData.include_tag:
+                            del tag_dict[each]
+                    break
+
+            struct_list.append ({'name':each, 'alias':'', 'count' : 0, 'level':struct_dict[each][0],
+                                 'tag':struct_dict[each][1], 'node':struct_dict[each][2], 'exclude': True if match else False})
+
+        # sort by level so that the bottom level struct will be build first to satisfy dependencies
+        struct_list = sorted(struct_list, key=lambda x: x['level'], reverse=True)
+
+        # Convert XXX_[0-9]+ to XXX as an array hint
+        for each in struct_list:
+            cfgs = each['node']
+            if 'struct' in cfgs['$STRUCT']:
+                each['alias'], array_num, var = self.get_struct_array_info (cfgs['$STRUCT']['struct'])
+            else:
+                match = re.match('(\w+)(_\d+)', each['name'])
+                if match:
+                    each['alias'] = match.group(1)
+                else:
+                    each['alias'] = each['name']
+
+        # count items for array build
+        for idx, each in enumerate(struct_list):
+            if idx > 0:
+                last_struct = struct_list[idx-1]['node']['$STRUCT']
+                curr_struct = each['node']['$STRUCT']
+                if struct_list[idx-1]['alias'] == each['alias'] and \
+                   curr_struct['length'] == last_struct['length'] and \
+                   curr_struct['offset'] == last_struct['offset'] + last_struct['length']:
+                   for idx2 in range (idx-1, -1, -1):
+                        if struct_list[idx2]['count'] > 0:
+                            struct_list[idx2]['count'] += 1
+                            break
+                   continue
+            each['count'] = 1
+
+        # generate common header
+        if com_hdr_file_name:
+            self.write_cfg_header_file (com_hdr_file_name, 0, tag_dict, struct_list)
+
+        # generate platform header
+        self.write_cfg_header_file (hdr_file_name, hdr_mode, tag_dict, struct_list)
+
+        return 0
+
+
+    def load_yaml (self, cfg_file):
+        cfg_yaml = CFG_YAML()
+        self.initialize ()
+        self._cfg_tree  = cfg_yaml.load_yaml (cfg_file)
+        self._def_dict  = cfg_yaml.def_dict
+        self._yaml_path = os.path.dirname(cfg_file)
+        self.build_cfg_list()
+        self.build_var_dict()
+        self.update_def_value()
+        return 0
+
+
+def usage():
+    print ('\n'.join([
+          "GenCfgData Version 0.50",
+          "Usage:",
+          "    GenCfgData  GENINC  BinFile              IncOutFile",
+          "    GenCfgData  GENPKL  YamlFile             PklOutFile",
+          "    GenCfgData  GENBIN  YamlFile[;DltFile]   BinOutFile",
+          "    GenCfgData  GENDLT  YamlFile[;BinFile]   DltOutFile",
+          "    GenCfgData  GENYML  YamlFile             YamlOutFile",
+          "    GenCfgData  GENHDR  YamlFile             HdrOutFile"
+          ]))
+
+
+def main():
+    # Parse the options and args
+    argc = len(sys.argv)
+    if argc < 4 or argc > 5:
+        usage()
+        return 1
+
+    gen_cfg_data = CGenCfgData()
+    command   = sys.argv[1].upper()
+    out_file  = sys.argv[3]
+
+    file_list  = sys.argv[2].split(';')
+    if len(file_list) >= 2:
+        yml_file   = file_list[0]
+        dlt_file   = file_list[1]
+    elif len(file_list) == 1:
+        yml_file   = file_list[0]
+        dlt_file   = ''
+    else:
+        raise Exception ("ERROR: Invalid parameter '%s' !" % sys.argv[2])
+
+    yml_scope = ''
+    if '@' in yml_file:
+        parts = yml_file.split('@')
+        yml_file  = parts[0]
+        yml_scope = parts[1]
+
+    if command == "GENDLT" and yml_file.endswith('.dlt'):
+        # It needs to expand an existing DLT file
+        dlt_file = yml_file
+        lines  = gen_cfg_data.expand_include_files (dlt_file)
+        write_lines (lines, out_file)
+        return 0
+
+    if command == "GENYML":
+        if not yml_file.lower().endswith('.yaml'):
+            raise Exception ('Only YAML file is supported !')
+        gen_cfg_data.generate_yml_file(yml_file, out_file)
+        return 0
+
+    bin_file = ''
+    if (yml_file.lower().endswith('.bin')) and (command == "GENINC"):
+        # It is binary file
+        bin_file = yml_file
+        yml_file = ''
+
+    if bin_file:
+        gen_cfg_data.generate_data_inc_file(out_file, bin_file)
+        return 0
+
+    cfg_bin_file  = ''
+    cfg_bin_file2 = ''
+    if dlt_file:
+        if command == "GENDLT":
+            cfg_bin_file = dlt_file
+            dlt_file  = ''
+            if len(file_list) >= 3:
+                cfg_bin_file2 = file_list[2]
+
+    if yml_file.lower().endswith('.pkl'):
+        with open(yml_file, "rb") as pkl_file:
+            gen_cfg_data.__dict__ = marshal.load(pkl_file)
+        gen_cfg_data.prepare_marshal (False)
+    else:
+        gen_cfg_data.load_yaml (yml_file)
+        if command == 'GENPKL':
+            gen_cfg_data.prepare_marshal (True)
+            with open(out_file, "wb") as pkl_file:
+                marshal.dump(gen_cfg_data.__dict__, pkl_file)
+            json_file = os.path.splitext(out_file)[0] + '.json'
+            fo = open (json_file, 'w')
+            path_list = []
+            cfgs = {'_cfg_page' : gen_cfg_data._cfg_page, '_cfg_list':gen_cfg_data._cfg_list, '_path_list' : path_list}
+            # optimize to reduce size
+            path = None
+            for each in cfgs['_cfg_list']:
+                new_path = each['path'][:-len(each['cname'])-1]
+                if path != new_path:
+                    path = new_path
+                    each['path'] = path
+                    path_list.append(path)
+                else:
+                    del each['path']
+                if each['order'] == each['offset']:
+                    del each['order']
+                del each['offset']
+
+                # value is just used to indicate display type
+                value = each['value']
+                if value.startswith ('0x'):
+                    hex_len = ((each['length'] + 7) // 8) * 2
+                    if len(value) == hex_len:
+                        value = 'x%d' % hex_len
+                    else:
+                        value = 'x'
+                    each['value'] = value
+                elif value and value[0] in ['"', "'", '{']:
+                    each['value'] = value[0]
+                else:
+                    del each['value']
+
+            fo.write(repr(cfgs))
+            fo.close ()
+            return 0
+
+    if dlt_file:
+        gen_cfg_data.override_default_value(dlt_file)
+
+    if   command == "GENBIN":
+        if len(file_list) == 3:
+            old_data = gen_cfg_data.generate_binary_array()
+            fi   = open (file_list[2], 'rb')
+            new_data = bytearray (fi.read ())
+            fi.close ()
+            if len(new_data) != len(old_data):
+                raise Exception ("Binary file '%s' length does not match, ignored !" % file_list[2])
+            else:
+                gen_cfg_data.load_default_from_bin (new_data)
+                gen_cfg_data.override_default_value(dlt_file)
+
+        gen_cfg_data.generate_binary(out_file, yml_scope)
+
+    elif command == "GENDLT":
+        gen_cfg_data.generate_delta_file (out_file, cfg_bin_file, cfg_bin_file2)
+
+    elif command == "GENHDR":
+        out_files = out_file.split(';')
+        brd_out_file = out_files[0].strip()
+        if len(out_files) > 1:
+            com_out_file = out_files[1].strip()
+        else:
+            com_out_file = ''
+        gen_cfg_data.create_header_file(brd_out_file, com_out_file, yml_scope)
+
+    elif command == "GENINC":
+        gen_cfg_data.generate_data_inc_file(out_file)
+
+    elif command == "DEBUG":
+        gen_cfg_data.print_cfgs()
+
+    else:
+        raise Exception ("Unsuported command '%s' !" % command)
+
+    return 0
+
+
+if __name__ == '__main__':
+    sys.exit(main())
diff --git a/IntelFsp2Pkg/Tools/GenCfgOpt.py b/IntelFsp2Pkg/Tools/GenCfgOpt.py
deleted file mode 100644
index 2fa7582d85..0000000000
--- a/IntelFsp2Pkg/Tools/GenCfgOpt.py
+++ /dev/null
@@ -1,1549 +0,0 @@
-## @ GenCfgOpt.py
-#
-# Copyright (c) 2014 - 2019, Intel Corporation. All rights reserved.<BR>
-# SPDX-License-Identifier: BSD-2-Clause-Patent
-#
-##
-
-import os
-import re
-import sys
-import struct
-from   datetime import date
-from functools import reduce
-
-# Generated file copyright header
-
-__copyright_txt__ = """## @file
-#
-#  THIS IS AUTO-GENERATED FILE BY BUILD TOOLS AND PLEASE DO NOT MAKE MODIFICATION.
-#
-#  This file lists all VPD informations for a platform collected by build.exe.
-#
-# Copyright (c) %4d, Intel Corporation. All rights reserved.<BR>
-# This program and the accompanying materials
-# are licensed and made available under the terms and conditions of the BSD License
-# which accompanies this distribution.  The full text of the license may be found at
-# http://opensource.org/licenses/bsd-license.php
-#
-# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-#
-"""
-
-__copyright_bsf__ = """/** @file
-
-  Boot Setting File for Platform Configuration.
-
-  Copyright (c) %4d, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-  This file is automatically generated. Please do NOT modify !!!
-
-**/
-
-"""
-
-__copyright_h__ = """/** @file
-
-Copyright (c) %4d, Intel Corporation. All rights reserved.<BR>
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-* Neither the name of Intel Corporation nor the names of its contributors may
-  be used to endorse or promote products derived from this software without
-  specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
-
-  This file is automatically generated. Please do NOT modify !!!
-
-**/
-"""
-
-BuildOptionPcd = []
-
-class CLogicalExpression:
-    def __init__(self):
-        self.index    = 0
-        self.string   = ''
-
-    def errExit(self, err = ''):
-        print ("ERROR: Express parsing for:")
-        print ("       %s" % self.string)
-        print ("       %s^" % (' ' * self.index))
-        if err:
-            print ("INFO : %s" % err)
-        raise SystemExit
-
-    def getNonNumber (self, n1, n2):
-        if not n1.isdigit():
-            return n1
-        if not n2.isdigit():
-            return n2
-        return None
-
-    def getCurr(self, lens = 1):
-        try:
-            if lens == -1:
-                return self.string[self.index :]
-            else:
-                if self.index + lens > len(self.string):
-                    lens = len(self.string) - self.index
-                return self.string[self.index : self.index + lens]
-        except Exception:
-            return ''
-
-    def isLast(self):
-        return self.index == len(self.string)
-
-    def moveNext(self, len = 1):
-        self.index += len
-
-    def skipSpace(self):
-        while not self.isLast():
-            if self.getCurr() in ' \t':
-                self.moveNext()
-            else:
-                return
-
-    def normNumber (self, val):
-        return True if val else False
-
-    def getNumber(self, var):
-        var = var.strip()
-        if   re.match('^0x[a-fA-F0-9]+$', var):
-            value = int(var, 16)
-        elif re.match('^[+-]?\d+$', var):
-            value = int(var, 10)
-        else:
-            value = None
-        return value
-
-    def parseValue(self):
-        self.skipSpace()
-        var = ''
-        while not self.isLast():
-            char = self.getCurr()
-            if re.match('^[\w.]', char):
-                var += char
-                self.moveNext()
-            else:
-                break
-        val = self.getNumber(var)
-        if val is None:
-            value = var
-        else:
-            value = "%d" % val
-        return value
-
-    def parseSingleOp(self):
-        self.skipSpace()
-        if re.match('^NOT\W', self.getCurr(-1)):
-            self.moveNext(3)
-            op  = self.parseBrace()
-            val = self.getNumber (op)
-            if val is None:
-                self.errExit ("'%s' is not a number" % op)
-            return "%d" % (not self.normNumber(int(op)))
-        else:
-            return self.parseValue()
-
-    def parseBrace(self):
-        self.skipSpace()
-        char = self.getCurr()
-        if char == '(':
-            self.moveNext()
-            value = self.parseExpr()
-            self.skipSpace()
-            if self.getCurr() != ')':
-                self.errExit ("Expecting closing brace or operator")
-            self.moveNext()
-            return value
-        else:
-            value = self.parseSingleOp()
-            return value
-
-    def parseCompare(self):
-        value = self.parseBrace()
-        while True:
-            self.skipSpace()
-            char = self.getCurr()
-            if char in ['<', '>']:
-                self.moveNext()
-                next = self.getCurr()
-                if next == '=':
-                    op = char + next
-                    self.moveNext()
-                else:
-                    op = char
-                result = self.parseBrace()
-                test = self.getNonNumber(result, value)
-                if test is None:
-                    value = "%d" % self.normNumber(eval (value + op + result))
-                else:
-                    self.errExit ("'%s' is not a valid number for comparision" % test)
-            elif char in ['=', '!']:
-                op = self.getCurr(2)
-                if op in ['==', '!=']:
-                    self.moveNext(2)
-                    result = self.parseBrace()
-                    test = self.getNonNumber(result, value)
-                    if test is None:
-                        value = "%d" % self.normNumber((eval (value + op + result)))
-                    else:
-                        value = "%d" % self.normNumber(eval ("'" + value + "'" + op + "'" + result + "'"))
-                else:
-                    break
-            else:
-                break
-        return value
-
-    def parseAnd(self):
-        value = self.parseCompare()
-        while True:
-            self.skipSpace()
-            if re.match('^AND\W', self.getCurr(-1)):
-                self.moveNext(3)
-                result = self.parseCompare()
-                test = self.getNonNumber(result, value)
-                if test is None:
-                    value = "%d" % self.normNumber(int(value) & int(result))
-                else:
-                    self.errExit ("'%s' is not a valid op number for AND" % test)
-            else:
-                break
-        return value
-
-    def parseOrXor(self):
-        value  = self.parseAnd()
-        op     = None
-        while True:
-            self.skipSpace()
-            op = None
-            if re.match('^XOR\W', self.getCurr(-1)):
-                self.moveNext(3)
-                op = '^'
-            elif re.match('^OR\W', self.getCurr(-1)):
-                self.moveNext(2)
-                op = '|'
-            else:
-                break
-            if op:
-                result = self.parseAnd()
-                test = self.getNonNumber(result, value)
-                if test is None:
-                    value = "%d" % self.normNumber(eval (value + op + result))
-                else:
-                    self.errExit ("'%s' is not a valid op number for XOR/OR" % test)
-        return value
-
-    def parseExpr(self):
-        return self.parseOrXor()
-
-    def getResult(self):
-        value = self.parseExpr()
-        self.skipSpace()
-        if not self.isLast():
-            self.errExit ("Unexpected character found '%s'" % self.getCurr())
-        test = self.getNumber(value)
-        if test is None:
-            self.errExit ("Result '%s' is not a number" % value)
-        return int(value)
-
-    def evaluateExpress (self, Expr):
-        self.index     = 0
-        self.string    = Expr
-        if self.getResult():
-            Result = True
-        else:
-            Result = False
-        return Result
-
-class CGenCfgOpt:
-    def __init__(self):
-        self.Debug          = False
-        self.Error          = ''
-
-        self._GlobalDataDef = """
-GlobalDataDef
-    SKUID = 0, "DEFAULT"
-EndGlobalData
-
-"""
-        self._BuidinOptionTxt = """
-List &EN_DIS
-    Selection 0x1 , "Enabled"
-    Selection 0x0 , "Disabled"
-EndList
-
-"""
-
-        self._BsfKeyList    = ['FIND','NAME','HELP','TYPE','PAGE','OPTION','ORDER']
-        self._HdrKeyList    = ['HEADER','STRUCT', 'EMBED', 'COMMENT']
-        self._BuidinOption  = {'$EN_DIS' : 'EN_DIS'}
-
-        self._MacroDict   = {}
-        self._PcdsDict    = {}
-        self._CfgBlkDict  = {}
-        self._CfgPageDict = {}
-        self._CfgItemList = []
-        self._DscFile     = ''
-        self._FvDir       = ''
-        self._MapVer      = 0
-
-    def ParseMacros (self, MacroDefStr):
-        # ['-DABC=1', '-D', 'CFG_DEBUG=1', '-D', 'CFG_OUTDIR=Build']
-        self._MacroDict = {}
-        IsExpression = False
-        for Macro in MacroDefStr:
-            if Macro.startswith('-D'):
-                IsExpression = True
-                if len(Macro) > 2:
-                    Macro = Macro[2:]
-                else :
-                    continue
-            if IsExpression:
-                IsExpression = False
-                Match = re.match("(\w+)=(.+)", Macro)
-                if Match:
-                    self._MacroDict[Match.group(1)] = Match.group(2)
-                else:
-                    Match = re.match("(\w+)", Macro)
-                    if Match:
-                        self._MacroDict[Match.group(1)] = ''
-        if len(self._MacroDict) == 0:
-            Error = 1
-        else:
-            Error = 0
-            if self.Debug:
-                print ("INFO : Macro dictionary:")
-                for Each in self._MacroDict:
-                    print ("       $(%s) = [ %s ]" % (Each , self._MacroDict[Each]))
-        return Error
-
-    def EvaulateIfdef   (self, Macro):
-        Result = Macro in self._MacroDict
-        if self.Debug:
-            print ("INFO : Eval Ifdef [%s] : %s" % (Macro, Result))
-        return  Result
-
-    def ExpandMacros (self, Input):
-        Line = Input
-        Match = re.findall("\$\(\w+\)", Input)
-        if Match:
-            for Each in Match:
-              Variable = Each[2:-1]
-              if Variable in self._MacroDict:
-                  Line = Line.replace(Each, self._MacroDict[Variable])
-              else:
-                  if self.Debug:
-                      print ("WARN : %s is not defined" % Each)
-                  Line = Line.replace(Each, Each[2:-1])
-        return Line
-
-    def ExpandPcds (self, Input):
-        Line = Input
-        Match = re.findall("(\w+\.\w+)", Input)
-        if Match:
-            for PcdName in Match:
-              if PcdName in self._PcdsDict:
-                  Line = Line.replace(PcdName, self._PcdsDict[PcdName])
-              else:
-                  if self.Debug:
-                      print ("WARN : %s is not defined" % PcdName)
-        return Line
-
-    def EvaluateExpress (self, Expr):
-        ExpExpr = self.ExpandPcds(Expr)
-        ExpExpr = self.ExpandMacros(ExpExpr)
-        LogExpr = CLogicalExpression()
-        Result  = LogExpr.evaluateExpress (ExpExpr)
-        if self.Debug:
-            print ("INFO : Eval Express [%s] : %s" % (Expr, Result))
-        return Result
-
-    def FormatListValue(self, ConfigDict):
-        Struct = ConfigDict['struct']
-        if Struct not in ['UINT8','UINT16','UINT32','UINT64']:
-            return
-
-        dataarray = []
-        binlist = ConfigDict['value'][1:-1].split(',')
-        for each in binlist:
-            each = each.strip()
-            if each.startswith('0x'):
-                value = int(each, 16)
-            else:
-                value = int(each)
-            dataarray.append(value)
-
-        unit = int(Struct[4:]) / 8
-        if int(ConfigDict['length']) != unit * len(dataarray):
-            raise Exception("Array size is not proper for '%s' !" % ConfigDict['cname'])
-
-        bytearray = []
-        for each in dataarray:
-            value = each
-            for loop in range(int(unit)):
-                bytearray.append("0x%02X" % (value & 0xFF))
-                value = value >> 8
-        newvalue  = '{'  + ','.join(bytearray) + '}'
-        ConfigDict['value'] = newvalue
-        return ""
-
-    def ParseDscFile (self, DscFile, FvDir):
-        Hardcode = False
-        AutoAlign = False
-        self._CfgItemList = []
-        self._CfgPageDict = {}
-        self._CfgBlkDict  = {}
-        self._DscFile     = DscFile
-        self._FvDir       = FvDir
-
-        IsDefSect       = False
-        IsPcdSect       = False
-        IsUpdSect       = False
-        IsVpdSect       = False
-
-        IfStack         = []
-        ElifStack       = []
-        Error           = 0
-        ConfigDict      = {}
-
-        DscFd        = open(DscFile, "r")
-        DscLines     = DscFd.readlines()
-        DscFd.close()
-
-        MaxAlign = 32   #Default align to 32, but if there are 64 bit unit, align to 64
-        SizeAlign = 0   #record the struct max align
-        while len(DscLines):
-            DscLine  = DscLines.pop(0).strip()
-            Handle   = False
-            Match    = re.match("^\[(.+)\]", DscLine)
-            if Match is not None:
-                IsDefSect = False
-                IsPcdSect = False
-                IsVpdSect = False
-                IsUpdSect = False
-                if  Match.group(1).lower() == "Defines".lower():
-                    IsDefSect = True
-                if  (Match.group(1).lower() == "PcdsFeatureFlag".lower() or Match.group(1).lower() == "PcdsFixedAtBuild".lower()):
-                    IsPcdSect = True
-                elif Match.group(1).lower() == "PcdsDynamicVpd.Upd".lower():
-                    ConfigDict = {}
-                    ConfigDict['header']  = 'ON'
-                    ConfigDict['region']  = 'UPD'
-                    ConfigDict['order']   = -1
-                    ConfigDict['page']    = ''
-                    ConfigDict['name']    = ''
-                    ConfigDict['find']    = ''
-                    ConfigDict['struct']  = ''
-                    ConfigDict['embed']   = ''
-                    ConfigDict['comment'] = ''
-                    ConfigDict['subreg']  = []
-                    IsUpdSect = True
-                    Offset    = 0
-            else:
-                if IsDefSect or IsPcdSect or IsUpdSect or IsVpdSect:
-                    if re.match("^!else($|\s+#.+)", DscLine):
-                        if IfStack:
-                            IfStack[-1] = not IfStack[-1]
-                        else:
-                            print("ERROR: No paired '!if' found for '!else' for line '%s'" % DscLine)
-                            raise SystemExit
-                    elif re.match("^!endif($|\s+#.+)", DscLine):
-                        if IfStack:
-                            IfStack.pop()
-                            Level = ElifStack.pop()
-                            if Level > 0:
-                                del IfStack[-Level:]
-                        else:
-                            print("ERROR: No paired '!if' found for '!endif' for line '%s'" % DscLine)
-                            raise SystemExit
-                    else:
-                        Result = False
-                        Match = re.match("!(ifdef|ifndef)\s+(.+)", DscLine)
-                        if Match:
-                            Result = self.EvaulateIfdef (Match.group(2))
-                            if Match.group(1) == 'ifndef':
-                                Result = not Result
-                            IfStack.append(Result)
-                            ElifStack.append(0)
-                        else:
-                            Match  = re.match("!(if|elseif)\s+(.+)", DscLine.split("#")[0])
-                            if Match:
-                                Result = self.EvaluateExpress(Match.group(2))
-                                if Match.group(1) == "if":
-                                    ElifStack.append(0)
-                                    IfStack.append(Result)
-                                else:   #elseif
-                                    if IfStack:
-                                        IfStack[-1] = not IfStack[-1]
-                                        IfStack.append(Result)
-                                        ElifStack[-1] = ElifStack[-1] + 1
-                                    else:
-                                        print("ERROR: No paired '!if' found for '!elif' for line '%s'" % DscLine)
-                                        raise SystemExit
-                            else:
-                                if IfStack:
-                                    Handle = reduce(lambda x,y: x and y, IfStack)
-                                else:
-                                    Handle = True
-                                if Handle:
-                                    Match = re.match("!include\s+(.+)", DscLine)
-                                    if Match:
-                                        IncludeFilePath = Match.group(1)
-                                        IncludeFilePath = self.ExpandMacros(IncludeFilePath)
-                                        PackagesPath = os.getenv("PACKAGES_PATH")
-                                        if PackagesPath:
-                                          for PackagePath in PackagesPath.split(os.pathsep):
-                                              IncludeFilePathAbs = os.path.join(os.path.normpath(PackagePath), os.path.normpath(IncludeFilePath))
-                                              if os.path.exists(IncludeFilePathAbs):
-                                                  IncludeDsc  = open(IncludeFilePathAbs, "r")
-                                                  break
-                                        else:
-                                          IncludeDsc  = open(IncludeFilePath, "r")
-                                        if IncludeDsc == None:
-                                            print("ERROR: Cannot open file '%s'" % IncludeFilePath)
-                                            raise SystemExit
-                                        NewDscLines = IncludeDsc.readlines()
-                                        IncludeDsc.close()
-                                        DscLines = NewDscLines + DscLines
-                                        Offset = 0
-                                    else:
-                                        if DscLine.startswith('!'):
-                                            print("ERROR: Unrecognized directive for line '%s'" % DscLine)
-                                            raise SystemExit
-            if not Handle:
-                continue
-
-            if IsDefSect:
-                #DEFINE UPD_TOOL_GUID       = 8C3D856A-9BE6-468E-850A-24F7A8D38E09
-                #DEFINE FSP_T_UPD_TOOL_GUID = 34686CA3-34F9-4901-B82A-BA630F0714C6
-                #DEFINE FSP_M_UPD_TOOL_GUID = 39A250DB-E465-4DD1-A2AC-E2BD3C0E2385
-                #DEFINE FSP_S_UPD_TOOL_GUID = CAE3605B-5B34-4C85-B3D7-27D54273C40F
-                Match = re.match("^\s*(?:DEFINE\s+)*(\w+)\s*=\s*([-.\w]+)", DscLine)
-                if Match:
-                    self._MacroDict[Match.group(1)] = Match.group(2)
-                    if self.Debug:
-                        print ("INFO : DEFINE %s = [ %s ]" % (Match.group(1), Match.group(2)))
-            elif IsPcdSect:
-                #gSiPkgTokenSpaceGuid.PcdTxtEnable|FALSE
-                #gSiPkgTokenSpaceGuid.PcdOverclockEnable|TRUE
-                Match = re.match("^\s*([\w\.]+)\s*\|\s*(\w+)", DscLine)
-                if Match:
-                    self._PcdsDict[Match.group(1)] = Match.group(2)
-                    if self.Debug:
-                        print ("INFO : PCD %s = [ %s ]" % (Match.group(1), Match.group(2)))
-                    i = 0
-                    while i < len(BuildOptionPcd):
-                        Match = re.match("\s*([\w\.]+)\s*\=\s*(\w+)", BuildOptionPcd[i])
-                        if Match:
-                            self._PcdsDict[Match.group(1)] = Match.group(2)
-                        i += 1
-            else:
-                Match = re.match("^\s*#\s+(!BSF|@Bsf|!HDR)\s+(.+)", DscLine)
-                if Match:
-                    Remaining = Match.group(2)
-                    if Match.group(1) == '!BSF' or Match.group(1) == '@Bsf':
-                        Match = re.match("(?:^|.+\s+)PAGES:{(.+?)}", Remaining)
-                        if Match:
-                            # !BSF PAGES:{HSW:"Haswell System Agent", LPT:"Lynx Point PCH"}
-                            PageList = Match.group(1).split(',')
-                            for Page in PageList:
-                                Page  = Page.strip()
-                                Match = re.match("(\w+):\"(.+)\"", Page)
-                                self._CfgPageDict[Match.group(1)] = Match.group(2)
-
-                        Match = re.match("(?:^|.+\s+)BLOCK:{NAME:\"(.+)\"\s*,\s*VER:\"(.+)\"\s*}", Remaining)
-                        if Match:
-                            self._CfgBlkDict['name'] = Match.group(1)
-                            self._CfgBlkDict['ver']  = Match.group(2)
-
-                        for Key in self._BsfKeyList:
-                            Match = re.match("(?:^|.+\s+)%s:{(.+?)}" % Key, Remaining)
-                            if Match:
-                                if Key in ['NAME', 'HELP', 'OPTION'] and Match.group(1).startswith('+'):
-                                    ConfigDict[Key.lower()] += Match.group(1)[1:]
-                                else:
-                                    ConfigDict[Key.lower()]  = Match.group(1)
-                    else:
-                        for Key in self._HdrKeyList:
-                            Match = re.match("(?:^|.+\s+)%s:{(.+?)}" % Key, Remaining)
-                            if Match:
-                                ConfigDict[Key.lower()]  = Match.group(1)
-
-                Match = re.match("^\s*#\s+@Prompt\s+(.+)", DscLine)
-                if Match:
-                    ConfigDict['name'] = Match.group(1)
-
-                Match = re.match("^\s*#\s*@ValidList\s*(.+)\s*\|\s*(.+)\s*\|\s*(.+)\s*", DscLine)
-                if Match:
-                    if Match.group(2).strip() in self._BuidinOption:
-                        ConfigDict['option'] = Match.group(2).strip()
-                    else:
-                        OptionValueList = Match.group(2).split(',')
-                        OptionStringList = Match.group(3).split(',')
-                        Index = 0
-                        for Option in OptionValueList:
-                             Option = Option.strip()
-                             ConfigDict['option'] = ConfigDict['option'] + str(Option) + ':' + OptionStringList[Index].strip()
-                             Index += 1
-                             if Index in range(len(OptionValueList)):
-                                 ConfigDict['option'] += ', '
-                    ConfigDict['type'] = "Combo"
-
-                Match = re.match("^\s*#\s*@ValidRange\s*(.+)\s*\|\s*(.+)\s*-\s*(.+)\s*", DscLine)
-                if Match:
-                    if "0x" in Match.group(2) or "0x" in Match.group(3):
-                       ConfigDict['type'] = "EditNum, HEX, (%s,%s)" % (Match.group(2), Match.group(3))
-                    else:
-                       ConfigDict['type'] = "EditNum, DEC, (%s,%s)" % (Match.group(2), Match.group(3))
-
-                Match = re.match("^\s*##\s+(.+)", DscLine)
-                if Match:
-                    ConfigDict['help'] = Match.group(1)
-
-                # Check VPD/UPD
-                if IsUpdSect:
-                    Match = re.match("^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\s*\|\s*(0x[0-9A-F]+|\*)\s*\|\s*(\d+|0x[0-9a-fA-F]+)\s*\|\s*(.+)",DscLine)
-                else:
-                    Match = re.match("^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\s*\|\s*(0x[0-9A-F]+)(?:\s*\|\s*(.+))?",  DscLine)
-                if Match:
-                    ConfigDict['space']  = Match.group(1)
-                    ConfigDict['cname']  = Match.group(2)
-                    if Match.group(3) != '*':
-                        Hardcode = True
-                        Offset =  int (Match.group(3), 16)
-                    else:
-                        AutoAlign = True
-
-                    if Hardcode and AutoAlign:
-                        print("Hardcode and auto-align mixed mode is not supported by GenCfgOpt")
-                        raise SystemExit
-                    ConfigDict['offset'] = Offset
-                    if ConfigDict['order'] == -1:
-                        ConfigDict['order'] = ConfigDict['offset'] << 8
-                    else:
-                        (Major, Minor) = ConfigDict['order'].split('.')
-                        ConfigDict['order'] = (int (Major, 16) << 8 ) +  int (Minor, 16)
-                    if IsUpdSect:
-                        Value = Match.group(5).strip()
-                        if Match.group(4).startswith("0x"):
-                            Length  = int (Match.group(4), 16)
-                        else :
-                            Length  = int (Match.group(4))
-                        Offset += Length
-                    else:
-                        Value = Match.group(4)
-                        if Value is None:
-                            Value = ''
-                        Value = Value.strip()
-                        if '|' in Value:
-                            Match = re.match("^.+\s*\|\s*(.+)", Value)
-                            if Match:
-                                Value = Match.group(1)
-                        Length = -1
-
-                    ConfigDict['length'] = Length
-                    Match = re.match("\$\((\w+)\)", Value)
-                    if Match:
-                        if Match.group(1) in self._MacroDict:
-                            Value = self._MacroDict[Match.group(1)]
-
-                    ConfigDict['value']  = Value
-                    if (len(Value) > 0)  and (Value[0] == '{'):
-                        Value = self.FormatListValue(ConfigDict)
-
-                    if ConfigDict['name']  == '':
-                        # Clear BSF specific items
-                        ConfigDict['bsfname']   = ''
-                        ConfigDict['help']   = ''
-                        ConfigDict['type']   = ''
-                        ConfigDict['option'] = ''
-                    if IsUpdSect and AutoAlign:
-                        ItemLength = int(ConfigDict['length'])
-                        ItemOffset = int(ConfigDict['offset'])
-                        ItemStruct = ConfigDict['struct']
-                        Unit = 1
-                        if ItemLength in [1, 2, 4, 8] and not ConfigDict['value'].startswith('{'):
-                            Unit = ItemLength
-                            # If there are 64 bit unit, align to 64
-                            if Unit == 8:
-                                MaxAlign = 64
-                                SizeAlign = 8
-                        if ItemStruct != '':
-                            UnitDict = {'UINT8':1, 'UINT16':2, 'UINT32':4, 'UINT64':8}
-                            if ItemStruct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:
-                                Unit = UnitDict[ItemStruct]
-                                # If there are 64 bit unit, align to 64
-                                if Unit == 8:
-                                    MaxAlign = 64
-                                SizeAlign = max(SizeAlign, Unit)
-                        if (ConfigDict['embed'].find(':START') != -1):
-                            Base = ItemOffset
-                        SubOffset = ItemOffset - Base
-                        SubRemainder = SubOffset % Unit
-                        if SubRemainder:
-                            Diff = Unit - SubRemainder
-                            Offset = Offset + Diff
-                            ItemOffset = ItemOffset + Diff
-
-                        if (ConfigDict['embed'].find(':END') != -1):
-                            Remainder = Offset % (MaxAlign/8)   # MaxAlign is either 32 or 64
-                            if Remainder:
-                                Diff = int((MaxAlign/8) - Remainder)
-                                Offset = Offset + Diff
-                                ItemOffset = ItemOffset + Diff
-                            MaxAlign = 32                       # Reset to default 32 align when struct end
-                        if (ConfigDict['cname'] == 'UpdTerminator'):
-                            # ItemLength is the size of UpdTerminator
-                            # Itemlength might be 16, 32, or 64
-                            # Struct align to 64 if UpdTerminator
-                            # or struct size is 64 bit, else align to 32
-                            Remainder = Offset % max(ItemLength/8, 4, SizeAlign)
-                            Offset = Offset + ItemLength
-                            if Remainder:
-                                Diff = int(max(ItemLength/8, 4, SizeAlign) - Remainder)
-                                ItemOffset = ItemOffset + Diff
-                        ConfigDict['offset'] = ItemOffset
-
-                    self._CfgItemList.append(ConfigDict.copy())
-                    ConfigDict['name']   = ''
-                    ConfigDict['find']   = ''
-                    ConfigDict['struct'] = ''
-                    ConfigDict['embed']  = ''
-                    ConfigDict['comment'] = ''
-                    ConfigDict['order']  = -1
-                    ConfigDict['subreg'] = []
-                    ConfigDict['option'] = ''
-                else:
-                    # It could be a virtual item as below
-                    # !BSF FIELD:{SerialDebugPortAddress0:1}
-                    # or
-                    # @Bsf FIELD:{SerialDebugPortAddress0:1b}
-                    Match = re.match("^\s*#\s+(!BSF|@Bsf)\s+FIELD:{(.+):(\d+)([Bb])?}", DscLine)
-                    if Match:
-                        SubCfgDict = ConfigDict.copy()
-                        if (Match.group(4) == None) or (Match.group(4) == 'B'):
-                          UnitBitLen = 8
-                        elif Match.group(4) == 'b':
-                          UnitBitLen = 1
-                        else:
-                          print("ERROR: Invalide BSF FIELD length for line '%s'" % DscLine)
-                          raise SystemExit
-                        SubCfgDict['cname']  = Match.group(2)
-                        SubCfgDict['bitlength'] = int (Match.group(3)) * UnitBitLen
-                        if SubCfgDict['bitlength'] > 0:
-                            LastItem =  self._CfgItemList[-1]
-                            if len(LastItem['subreg']) == 0:
-                                SubOffset  = 0
-                            else:
-                                SubOffset  = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']
-                            SubCfgDict['bitoffset'] = SubOffset
-                            LastItem['subreg'].append (SubCfgDict.copy())
-                        ConfigDict['name']   = ''
-        return Error
-
-    def GetBsfBitFields (self, subitem, bytes):
-        start = subitem['bitoffset']
-        end   = start + subitem['bitlength']
-        bitsvalue = ''.join('{0:08b}'.format(i) for i in bytes[::-1])
-        bitsvalue = bitsvalue[::-1]
-        bitslen   = len(bitsvalue)
-        if start > bitslen or end > bitslen:
-            print ("Invalid bits offset [%d,%d] for %s" % (start, end, subitem['name']))
-            raise SystemExit
-        return hex(int(bitsvalue[start:end][::-1], 2))
-
-    def UpdateSubRegionDefaultValue (self):
-        Error = 0
-        for Item in self._CfgItemList:
-            if len(Item['subreg']) == 0:
-                continue
-            bytearray = []
-            if Item['value'][0] == '{':
-                binlist = Item['value'][1:-1].split(',')
-                for each in binlist:
-                    each = each.strip()
-                    if each.startswith('0x'):
-                        value = int(each, 16)
-                    else:
-                        value = int(each)
-                    bytearray.append(value)
-            else:
-                if Item['value'].startswith('0x'):
-                    value = int(Item['value'], 16)
-                else:
-                    value = int(Item['value'])
-                idx = 0
-                while  idx < Item['length']:
-                    bytearray.append(value & 0xFF)
-                    value = value >> 8
-                    idx = idx + 1
-            for SubItem in Item['subreg']:
-                valuestr = self.GetBsfBitFields(SubItem, bytearray)
-                SubItem['value'] = valuestr
-        return Error
-
-    def CreateSplitUpdTxt (self, UpdTxtFile):
-        GuidList = ['FSP_T_UPD_TOOL_GUID','FSP_M_UPD_TOOL_GUID','FSP_S_UPD_TOOL_GUID']
-        SignatureList = ['0x545F', '0x4D5F','0x535F']        #  _T, _M, and _S signature for FSPT, FSPM, FSPS
-        for Index in range(len(GuidList)):
-            UpdTxtFile = ''
-            FvDir = self._FvDir
-            if GuidList[Index] not in self._MacroDict:
-                self.Error = "%s definition is missing in DSC file" % (GuidList[Index])
-                return 1
-
-            if UpdTxtFile == '':
-                UpdTxtFile = os.path.join(FvDir, self._MacroDict[GuidList[Index]] + '.txt')
-
-            ReCreate = False
-            if not os.path.exists(UpdTxtFile):
-                ReCreate = True
-            else:
-                DscTime = os.path.getmtime(self._DscFile)
-                TxtTime = os.path.getmtime(UpdTxtFile)
-                if DscTime > TxtTime:
-                    ReCreate = True
-
-            if not  ReCreate:
-                # DSC has not been modified yet
-                # So don't have to re-generate other files
-                self.Error = 'No DSC file change, skip to create UPD TXT file'
-                return 256
-
-            TxtFd = open(UpdTxtFile, "w")
-            TxtFd.write("%s\n"   % (__copyright_txt__ % date.today().year))
-
-            NextOffset = 0
-            SpaceIdx   = 0
-            StartAddr  = 0
-            EndAddr    = 0
-            Default = 'DEFAULT|'
-            InRange = False
-            for Item in self._CfgItemList:
-                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:
-                    StartAddr = Item['offset']
-                    NextOffset = StartAddr
-                    InRange = True
-                if Item['cname'] == 'UpdTerminator' and InRange == True:
-                    EndAddr = Item['offset']
-                    InRange = False
-            InRange = False
-            for Item in self._CfgItemList:
-                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:
-                    InRange = True
-                if InRange != True:
-                    continue
-                if Item['cname'] == 'UpdTerminator':
-                    InRange = False
-                if Item['region'] != 'UPD':
-                    continue
-                Offset = Item['offset']
-                if StartAddr > Offset or EndAddr < Offset:
-                    continue
-                if NextOffset < Offset:
-                    # insert one line
-                    TxtFd.write("%s.UnusedUpdSpace%d|%s0x%04X|0x%04X|{0}\n" % (Item['space'], SpaceIdx, Default, NextOffset - StartAddr, Offset - NextOffset))
-                    SpaceIdx = SpaceIdx + 1
-                NextOffset = Offset + Item['length']
-                TxtFd.write("%s.%s|%s0x%04X|%s|%s\n" % (Item['space'],Item['cname'],Default,Item['offset'] - StartAddr,Item['length'],Item['value']))
-            TxtFd.close()
-        return 0
-
-    def ProcessMultilines (self, String, MaxCharLength):
-            Multilines = ''
-            StringLength = len(String)
-            CurrentStringStart = 0
-            StringOffset = 0
-            BreakLineDict = []
-            if len(String) <= MaxCharLength:
-                while (StringOffset < StringLength):
-                    if StringOffset >= 1:
-                        if String[StringOffset - 1] == '\\' and String[StringOffset] == 'n':
-                            BreakLineDict.append (StringOffset + 1)
-                    StringOffset += 1
-                if BreakLineDict != []:
-                    for Each in BreakLineDict:
-                        Multilines += "  %s\n" % String[CurrentStringStart:Each].lstrip()
-                        CurrentStringStart = Each
-                    if StringLength - CurrentStringStart > 0:
-                        Multilines += "  %s\n" % String[CurrentStringStart:].lstrip()
-                else:
-                    Multilines = "  %s\n" % String
-            else:
-                NewLineStart = 0
-                NewLineCount = 0
-                FoundSpaceChar = False
-                while (StringOffset < StringLength):
-                    if StringOffset >= 1:
-                        if NewLineCount >= MaxCharLength - 1:
-                            if String[StringOffset] == ' ' and StringLength - StringOffset > 10:
-                                BreakLineDict.append (NewLineStart + NewLineCount)
-                                NewLineStart = NewLineStart + NewLineCount
-                                NewLineCount = 0
-                                FoundSpaceChar = True
-                            elif StringOffset == StringLength - 1 and FoundSpaceChar == False:
-                                BreakLineDict.append (0)
-                        if String[StringOffset - 1] == '\\' and String[StringOffset] == 'n':
-                            BreakLineDict.append (StringOffset + 1)
-                            NewLineStart = StringOffset + 1
-                            NewLineCount = 0
-                    StringOffset += 1
-                    NewLineCount += 1
-                if BreakLineDict != []:
-                    BreakLineDict.sort ()
-                    for Each in BreakLineDict:
-                        if Each > 0:
-                            Multilines += "  %s\n" % String[CurrentStringStart:Each].lstrip()
-                        CurrentStringStart = Each
-                    if StringLength - CurrentStringStart > 0:
-                        Multilines += "  %s\n" % String[CurrentStringStart:].lstrip()
-            return Multilines
-
-    def CreateField (self, Item, Name, Length, Offset, Struct, BsfName, Help, Option):
-        PosName    = 28
-        PosComment = 30
-        NameLine=''
-        HelpLine=''
-        OptionLine=''
-
-        IsArray = False
-        if Length in [1,2,4,8]:
-            Type = "UINT%d" % (Length * 8)
-            if Name.startswith("UnusedUpdSpace") and Length != 1:
-                IsArray = True
-                Type = "UINT8"
-        else:
-            IsArray = True
-            Type = "UINT8"
-
-        if Item and Item['value'].startswith('{'):
-            Type = "UINT8"
-            IsArray = True
-
-        if Struct != '':
-            Type = Struct
-            if Struct in ['UINT8','UINT16','UINT32','UINT64']:
-                IsArray = True
-                Unit = int(Type[4:]) / 8
-                Length = Length / Unit
-            else:
-                IsArray = False
-
-        if IsArray:
-            Name = Name + '[%d]' % Length
-
-        if len(Type) < PosName:
-            Space1 = PosName - len(Type)
-        else:
-            Space1 = 1
-
-        if BsfName != '':
-            NameLine=" - %s\n" % BsfName
-        else:
-            NameLine="\n"
-
-        if Help != '':
-            HelpLine = self.ProcessMultilines (Help, 80)
-
-        if Option != '':
-            OptionLine = self.ProcessMultilines (Option, 80)
-
-        if Offset is None:
-            OffsetStr = '????'
-        else:
-            OffsetStr = '0x%04X' % Offset
-
-        return "\n/** Offset %s%s%s%s**/\n  %s%s%s;\n" % (OffsetStr, NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name,)
-
-    def PostProcessBody (self, TextBody):
-        NewTextBody = []
-        OldTextBody = []
-        IncludeLine = False
-        StructName  = ''
-        VariableName = ''
-        IsUpdHdrDefined = False
-        IsUpdHeader = False
-        for Line in TextBody:
-           SplitToLines = Line.splitlines()
-           MatchComment = re.match("^/\*\sCOMMENT:(\w+):([\w|\W|\s]+)\s\*/\s([\s\S]*)", SplitToLines[0])
-           if MatchComment:
-              if MatchComment.group(1) == 'FSP_UPD_HEADER':
-                  IsUpdHeader = True
-              else:
-                  IsUpdHeader = False
-              if IsUpdHdrDefined != True or IsUpdHeader != True:
-                CommentLine = " " + MatchComment.group(2) + "\n"
-                NewTextBody.append("/**" + CommentLine + "**/\n")
-              Line = Line[(len(SplitToLines[0]) + 1):]
-
-           Match = re.match("^/\*\sEMBED_STRUCT:(\w+):(\w+):(START|END)\s\*/\s([\s\S]*)", Line)
-           if Match:
-               Line = Match.group(4)
-               if Match.group(1) == 'FSP_UPD_HEADER':
-                   IsUpdHeader = True
-               else:
-                   IsUpdHeader = False
-
-           if Match and Match.group(3) == 'START':
-               if IsUpdHdrDefined != True or IsUpdHeader != True:
-                   NewTextBody.append ('typedef struct {\n')
-               StructName   = Match.group(1)
-               VariableName = Match.group(2)
-               MatchOffset = re.search('/\*\*\sOffset\s0x([a-fA-F0-9]+)', Line)
-               if MatchOffset:
-                   Offset = int(MatchOffset.group(1), 16)
-               else:
-                   Offset = None
-               Line
-               IncludeLine = True
-               OldTextBody.append (self.CreateField (None, VariableName, 0, Offset, StructName, '', '', ''))
-           if IncludeLine:
-               if IsUpdHdrDefined != True or IsUpdHeader != True:
-                   NewTextBody.append (Line)
-           else:
-               OldTextBody.append (Line)
-
-           if Match and Match.group(3) == 'END':
-               if (StructName != Match.group(1)) or (VariableName != Match.group(2)):
-                   print ("Unmatched struct name '%s' and '%s' !"  % (StructName, Match.group(1)))
-               else:
-                   if IsUpdHdrDefined != True or IsUpdHeader != True:
-                      NewTextBody.append ('} %s;\n\n' %  StructName)
-                      IsUpdHdrDefined = True
-               IncludeLine = False
-        NewTextBody.extend(OldTextBody)
-        return NewTextBody
-
-    def WriteLinesWithoutTailingSpace (self, HeaderFd, Line):
-        TxtBody2 = Line.splitlines(True)
-        for Line2 in TxtBody2:
-            Line2 = Line2.rstrip()
-            Line2 += '\n'
-            HeaderFd.write (Line2)
-        return 0
-    def CreateHeaderFile (self, InputHeaderFile):
-        FvDir = self._FvDir
-
-        HeaderFileName = 'FspUpd.h'
-        HeaderFile = os.path.join(FvDir, HeaderFileName)
-
-        # Check if header needs to be recreated
-        ReCreate = False
-
-        TxtBody = []
-        for Item in self._CfgItemList:
-           if str(Item['cname']) == 'Signature' and Item['length'] == 8:
-               Value = int(Item['value'], 16)
-               Chars = []
-               while Value != 0x0:
-                   Chars.append(chr(Value & 0xFF))
-                   Value = Value >> 8
-               SignatureStr = ''.join(Chars)
-               # Signature will be _T / _M / _S for FSPT / FSPM / FSPS accordingly
-               if '_T' in SignatureStr[6:6+2]:
-                   TxtBody.append("#define FSPT_UPD_SIGNATURE               %s        /* '%s' */\n\n" % (Item['value'], SignatureStr))
-               elif '_M' in SignatureStr[6:6+2]:
-                   TxtBody.append("#define FSPM_UPD_SIGNATURE               %s        /* '%s' */\n\n" % (Item['value'], SignatureStr))
-               elif '_S' in SignatureStr[6:6+2]:
-                   TxtBody.append("#define FSPS_UPD_SIGNATURE               %s        /* '%s' */\n\n" % (Item['value'], SignatureStr))
-        TxtBody.append("\n")
-
-        for Region in ['UPD']:
-            UpdOffsetTable = []
-            UpdSignature = ['0x545F', '0x4D5F', '0x535F']   #['_T', '_M', '_S'] signature for FSPT, FSPM, FSPS
-            UpdStructure = ['FSPT_UPD', 'FSPM_UPD', 'FSPS_UPD']
-            for Item in self._CfgItemList:
-                if Item["cname"] == 'Signature' and Item["value"][0:6] in UpdSignature:
-                    UpdOffsetTable.append (Item["offset"])
-
-            for UpdIdx in range(len(UpdOffsetTable)):
-                CommentLine = ""
-                for Item in self._CfgItemList:
-                    if Item["comment"] != '' and Item["offset"] >= UpdOffsetTable[UpdIdx]:
-                        MatchComment = re.match("^(U|V)PD_DATA_REGION:([\w|\W|\s]+)", Item["comment"])
-                        if MatchComment and MatchComment.group(1) == Region[0]:
-                            CommentLine = " " + MatchComment.group(2) + "\n"
-                            TxtBody.append("/**" + CommentLine + "**/\n")
-                    elif Item["offset"] >= UpdOffsetTable[UpdIdx] and Item["comment"] == '':
-                        Match = re.match("^FSP([\w|\W|\s])_UPD", UpdStructure[UpdIdx])
-                        if Match:
-                            TxtBody.append("/** Fsp " + Match.group(1) + " UPD Configuration\n**/\n")
-                TxtBody.append("typedef struct {\n")
-                NextOffset  = 0
-                SpaceIdx    = 0
-                Offset      = 0
-
-                LastVisible = True
-                ResvOffset  = 0
-                ResvIdx     = 0
-                LineBuffer  = []
-                InRange = False
-                for Item in self._CfgItemList:
-                    if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == UpdSignature[UpdIdx] or Region[0] == 'V':
-                        InRange = True
-                    if InRange != True:
-                        continue
-                    if Item['cname'] == 'UpdTerminator':
-                        InRange = False
-
-                    if Item['region'] != Region:
-                        continue
-
-                    if Item["offset"] < UpdOffsetTable[UpdIdx]:
-                        continue
-
-                    NextVisible = LastVisible
-
-                    if LastVisible and (Item['header'] == 'OFF'):
-                        NextVisible = False
-                        ResvOffset  = Item['offset']
-                    elif (not LastVisible) and Item['header'] == 'ON':
-                        NextVisible = True
-                        Name = "Reserved" + Region[0] + "pdSpace%d" % ResvIdx
-                        ResvIdx = ResvIdx + 1
-                        TxtBody.append(self.CreateField (Item, Name, Item["offset"] - ResvOffset, ResvOffset, '', '', '', ''))
-
-                    if  Offset < Item["offset"]:
-                        if LastVisible:
-                            Name = "Unused" + Region[0] + "pdSpace%d" % SpaceIdx
-                            LineBuffer.append(self.CreateField (Item, Name, Item["offset"] - Offset, Offset, '', '', '', ''))
-                        SpaceIdx = SpaceIdx + 1
-                        Offset   = Item["offset"]
-
-                    LastVisible = NextVisible
-
-                    Offset = Offset + Item["length"]
-                    if LastVisible:
-                        for Each in LineBuffer:
-                            TxtBody.append (Each)
-                        LineBuffer = []
-                        Comment = Item["comment"]
-                        Embed = Item["embed"].upper()
-                        if Embed.endswith(':START') or Embed.endswith(':END'):
-                            if not Comment == '' and Embed.endswith(':START'):
-                               Marker = '/* COMMENT:%s */ \n' % Item["comment"]
-                               Marker = Marker + '/* EMBED_STRUCT:%s */ ' % Item["embed"]
-                            else:
-                               Marker = '/* EMBED_STRUCT:%s */ ' % Item["embed"]
-                        else:
-                            if Embed == '':
-                                Marker = ''
-                            else:
-                                self.Error = "Invalid embedded structure format '%s'!\n" % Item["embed"]
-                                return 4
-                        Line = Marker + self.CreateField (Item, Item["cname"], Item["length"], Item["offset"], Item['struct'], Item['name'], Item['help'], Item['option'])
-                        TxtBody.append(Line)
-                    if Item['cname'] == 'UpdTerminator':
-                        break
-                TxtBody.append("} " + UpdStructure[UpdIdx] + ";\n\n")
-
-        # Handle the embedded data structure
-        TxtBody = self.PostProcessBody (TxtBody)
-
-        HeaderTFileName = 'FsptUpd.h'
-        HeaderMFileName = 'FspmUpd.h'
-        HeaderSFileName = 'FspsUpd.h'
-
-        UpdRegionCheck = ['FSPT', 'FSPM', 'FSPS']     # FSPX_UPD_REGION
-        UpdConfigCheck = ['FSP_T', 'FSP_M', 'FSP_S']  # FSP_X_CONFIG, FSP_X_TEST_CONFIG, FSP_X_RESTRICTED_CONFIG
-        UpdSignatureCheck = ['FSPT_UPD_SIGNATURE', 'FSPM_UPD_SIGNATURE', 'FSPS_UPD_SIGNATURE']
-        ExcludedSpecificUpd = 'FSPM_ARCH_UPD'
-
-        if InputHeaderFile != '':
-            if not os.path.exists(InputHeaderFile):
-                 self.Error = "Input header file '%s' does not exist" % InputHeaderFile
-                 return 6
-
-            InFd         = open(InputHeaderFile, "r")
-            IncLines     = InFd.readlines()
-            InFd.close()
-
-        for item in range(len(UpdRegionCheck)):
-            if UpdRegionCheck[item] == 'FSPT':
-                HeaderFd = open(os.path.join(FvDir, HeaderTFileName), "w")
-                FileBase = os.path.basename(os.path.join(FvDir, HeaderTFileName))
-            elif UpdRegionCheck[item] == 'FSPM':
-                HeaderFd = open(os.path.join(FvDir, HeaderMFileName), "w")
-                FileBase = os.path.basename(os.path.join(FvDir, HeaderMFileName))
-            elif UpdRegionCheck[item] == 'FSPS':
-                HeaderFd = open(os.path.join(FvDir, HeaderSFileName), "w")
-                FileBase = os.path.basename(os.path.join(FvDir, HeaderSFileName))
-            FileName = FileBase.replace(".", "_").upper()
-            HeaderFd.write("%s\n"   % (__copyright_h__ % date.today().year))
-            HeaderFd.write("#ifndef __%s__\n"   % FileName)
-            HeaderFd.write("#define __%s__\n\n" % FileName)
-            HeaderFd.write("#include <%s>\n\n" % HeaderFileName)
-            HeaderFd.write("#pragma pack(1)\n\n")
-
-            Export = False
-            for Line in IncLines:
-                Match = re.search ("!EXPORT\s+([A-Z]+)\s+EXTERNAL_BOOTLOADER_STRUCT_(BEGIN|END)\s+", Line)
-                if Match:
-                    if Match.group(2) == "BEGIN" and Match.group(1) == UpdRegionCheck[item]:
-                        Export = True
-                        continue
-                    else:
-                        Export = False
-                        continue
-                if Export:
-                    HeaderFd.write(Line)
-            HeaderFd.write("\n")
-
-            Index = 0
-            StartIndex = 0
-            EndIndex = 0
-            StructStart = []
-            StructStartWithComment = []
-            StructEnd = []
-            for Line in TxtBody:
-                Index += 1
-                Match = re.match("(typedef struct {)", Line)
-                if Match:
-                    StartIndex = Index - 1
-                Match = re.match("}\s([_A-Z0-9]+);", Line)
-                if Match and (UpdRegionCheck[item] in Match.group(1) or UpdConfigCheck[item] in Match.group(1)) and (ExcludedSpecificUpd not in Match.group(1)):
-                    EndIndex = Index
-                    StructStart.append(StartIndex)
-                    StructEnd.append(EndIndex)
-            Index = 0
-            for Line in TxtBody:
-                Index += 1
-                for Item in range(len(StructStart)):
-                    if Index == StructStart[Item]:
-                        Match = re.match("^(/\*\*\s*)", Line)
-                        if Match:
-                            StructStartWithComment.append(StructStart[Item])
-                        else:
-                            StructStartWithComment.append(StructStart[Item] + 1)
-            Index = 0
-            for Line in TxtBody:
-                Index += 1
-                for Item in range(len(StructStart)):
-                    if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:
-                        self.WriteLinesWithoutTailingSpace(HeaderFd, Line)
-            HeaderFd.write("#pragma pack()\n\n")
-            HeaderFd.write("#endif\n")
-            HeaderFd.close()
-
-        HeaderFd = open(HeaderFile, "w")
-        FileBase = os.path.basename(HeaderFile)
-        FileName = FileBase.replace(".", "_").upper()
-        HeaderFd.write("%s\n"   % (__copyright_h__ % date.today().year))
-        HeaderFd.write("#ifndef __%s__\n"   % FileName)
-        HeaderFd.write("#define __%s__\n\n" % FileName)
-        HeaderFd.write("#include <FspEas.h>\n\n")
-        HeaderFd.write("#pragma pack(1)\n\n")
-
-        for item in range(len(UpdRegionCheck)):
-            Index = 0
-            StartIndex = 0
-            EndIndex = 0
-            StructStart = []
-            StructStartWithComment = []
-            StructEnd = []
-            for Line in TxtBody:
-                Index += 1
-                Match = re.match("(typedef struct {)", Line)
-                if Match:
-                    StartIndex = Index - 1
-                Match = re.match("#define\s([_A-Z0-9]+)\s*", Line)
-                if Match and (UpdSignatureCheck[item] in Match.group(1) or UpdSignatureCheck[item] in Match.group(1)):
-                    StructStart.append(Index - 1)
-                    StructEnd.append(Index)
-            Index = 0
-            for Line in TxtBody:
-                Index += 1
-                for Item in range(len(StructStart)):
-                    if Index == StructStart[Item]:
-                        Match = re.match("^(/\*\*\s*)", Line)
-                        if Match:
-                            StructStartWithComment.append(StructStart[Item])
-                        else:
-                            StructStartWithComment.append(StructStart[Item] + 1)
-            Index = 0
-            for Line in TxtBody:
-                Index += 1
-                for Item in range(len(StructStart)):
-                    if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:
-                        self.WriteLinesWithoutTailingSpace(HeaderFd, Line)
-        HeaderFd.write("#pragma pack()\n\n")
-        HeaderFd.write("#endif\n")
-        HeaderFd.close()
-
-        return 0
-
-    def WriteBsfStruct  (self, BsfFd, Item):
-        LogExpr = CLogicalExpression()
-        if Item['type'] == "None":
-            Space = "gPlatformFspPkgTokenSpaceGuid"
-        else:
-            Space = Item['space']
-        Line = "    $%s_%s" % (Space, Item['cname'])
-        Match = re.match("\s*\{([x0-9a-fA-F,\s]+)\}\s*", Item['value'])
-        if Match:
-            DefaultValue = Match.group(1).strip()
-        else:
-            DefaultValue = Item['value'].strip()
-        if 'bitlength' in Item:
-            BsfFd.write("    %s%s%4d bits     $_DEFAULT_ = %s\n" % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))
-        else:
-            BsfFd.write("    %s%s%4d bytes    $_DEFAULT_ = %s\n" % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))
-        TmpList = []
-        if  Item['type'] == "Combo":
-            if not Item['option'] in self._BuidinOption:
-                OptList = Item['option'].split(',')
-                for Option in OptList:
-                    Option = Option.strip()
-                    (OpVal, OpStr) = Option.split(':')
-                    test = LogExpr.getNumber (OpVal)
-                    if test is None:
-                        raise Exception("Selection Index '%s' is not a number" % OpVal)
-                    TmpList.append((OpVal, OpStr))
-        return  TmpList
-
-    def WriteBsfOption  (self, BsfFd, Item):
-        PcdName   = Item['space'] + '_' + Item['cname']
-        WriteHelp = 0
-        if Item['type'] == "Combo":
-            if Item['option'] in self._BuidinOption:
-                Options = self._BuidinOption[Item['option']]
-            else:
-                Options = PcdName
-            BsfFd.write('    %s $%s, "%s", &%s,\n' % (Item['type'], PcdName, Item['name'], Options))
-            WriteHelp = 1
-        elif Item['type'].startswith("EditNum"):
-            Match = re.match("EditNum\s*,\s*(HEX|DEC)\s*,\s*\((\d+|0x[0-9A-Fa-f]+)\s*,\s*(\d+|0x[0-9A-Fa-f]+)\)", Item['type'])
-            if Match:
-                BsfFd.write('    EditNum $%s, "%s", %s,\n' % (PcdName, Item['name'], Match.group(1)))
-                WriteHelp = 2
-        elif Item['type'].startswith("EditText"):
-            BsfFd.write('    %s $%s, "%s",\n' % (Item['type'], PcdName, Item['name']))
-            WriteHelp = 1
-        elif Item['type'] == "Table":
-            Columns = Item['option'].split(',')
-            if len(Columns) != 0:
-                BsfFd.write('    %s $%s "%s",' % (Item['type'], PcdName, Item['name']))
-                for Col in Columns:
-                    Fmt = Col.split(':')
-                    if len(Fmt) != 3:
-                        raise Exception("Column format '%s' is invalid !" % Fmt)
-                    try:
-                        Dtype = int(Fmt[1].strip())
-                    except:
-                        raise Exception("Column size '%s' is invalid !" % Fmt[1])
-                    BsfFd.write('\n        Column "%s", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))
-                BsfFd.write(',\n')
-                WriteHelp = 1
-
-        if WriteHelp  > 0:
-            HelpLines = Item['help'].split('\\n\\r')
-            FirstLine = True
-            for HelpLine in HelpLines:
-                if FirstLine:
-                    FirstLine = False
-                    BsfFd.write('        Help "%s"\n' % (HelpLine))
-                else:
-                    BsfFd.write('             "%s"\n' % (HelpLine))
-            if WriteHelp == 2:
-                    BsfFd.write('             "Valid range: %s ~ %s"\n' % (Match.group(2), Match.group(3)))
-
-    def GenerateBsfFile (self, BsfFile):
-
-        if BsfFile == '':
-            self.Error = "BSF output file '%s' is invalid" % BsfFile
-            return 1
-
-        Error = 0
-        OptionDict = {}
-        BsfFd      = open(BsfFile, "w")
-        BsfFd.write("%s\n" % (__copyright_bsf__ % date.today().year))
-        BsfFd.write("%s\n" % self._GlobalDataDef)
-        BsfFd.write("StructDef\n")
-        NextOffset = -1
-        for Item in self._CfgItemList:
-            if Item['find'] != '':
-                BsfFd.write('\n    Find "%s"\n' % Item['find'])
-                NextOffset = Item['offset'] + Item['length']
-            if Item['name'] != '':
-                if NextOffset != Item['offset']:
-                    BsfFd.write("        Skip %d bytes\n" % (Item['offset'] - NextOffset))
-                if len(Item['subreg']) > 0:
-                    NextOffset =  Item['offset']
-                    BitsOffset =  NextOffset * 8
-                    for SubItem in Item['subreg']:
-                        BitsOffset += SubItem['bitlength']
-                        if SubItem['name'] == '':
-                            if 'bitlength' in SubItem:
-                                BsfFd.write("        Skip %d bits\n" % (SubItem['bitlength']))
-                            else:
-                                BsfFd.write("        Skip %d bytes\n" % (SubItem['length']))
-                        else:
-                            Options = self.WriteBsfStruct(BsfFd, SubItem)
-                            if len(Options) > 0:
-                                OptionDict[SubItem['space']+'_'+SubItem['cname']] = Options
-
-                    NextBitsOffset = (Item['offset'] + Item['length']) * 8
-                    if NextBitsOffset > BitsOffset:
-                        BitsGap     = NextBitsOffset - BitsOffset
-                        BitsRemain  = BitsGap % 8
-                        if BitsRemain:
-                            BsfFd.write("        Skip %d bits\n" % BitsRemain)
-                            BitsGap -= BitsRemain
-                        BytesRemain = int(BitsGap / 8)
-                        if BytesRemain:
-                            BsfFd.write("        Skip %d bytes\n" % BytesRemain)
-                    NextOffset = Item['offset'] + Item['length']
-                else:
-                    NextOffset = Item['offset'] + Item['length']
-                    Options = self.WriteBsfStruct(BsfFd, Item)
-                    if len(Options) > 0:
-                        OptionDict[Item['space']+'_'+Item['cname']] = Options
-        BsfFd.write("\nEndStruct\n\n")
-
-        BsfFd.write("%s" % self._BuidinOptionTxt)
-
-        for Each in OptionDict:
-            BsfFd.write("List &%s\n" % Each)
-            for Item in OptionDict[Each]:
-                BsfFd.write('    Selection %s , "%s"\n' % (Item[0], Item[1]))
-            BsfFd.write("EndList\n\n")
-
-        BsfFd.write("BeginInfoBlock\n")
-        BsfFd.write('    PPVer       "%s"\n' % (self._CfgBlkDict['ver']))
-        BsfFd.write('    Description "%s"\n' % (self._CfgBlkDict['name']))
-        BsfFd.write("EndInfoBlock\n\n")
-
-        for Each in self._CfgPageDict:
-            BsfFd.write('Page "%s"\n' % self._CfgPageDict[Each])
-            BsfItems = []
-            for Item in self._CfgItemList:
-                if Item['name'] != '':
-                    if Item['page'] != Each:
-                        continue
-                    if len(Item['subreg']) > 0:
-                        for SubItem in Item['subreg']:
-                            if SubItem['name'] != '':
-                                BsfItems.append(SubItem)
-                    else:
-                        BsfItems.append(Item)
-
-            BsfItems.sort(key=lambda x: x['order'])
-
-            for Item in BsfItems:
-                self.WriteBsfOption (BsfFd, Item)
-            BsfFd.write("EndPage\n\n")
-
-        BsfFd.close()
-        return  Error
-
-
-def Usage():
-    print ("GenCfgOpt Version 0.54")
-    print ("Usage:")
-    print ("    GenCfgOpt  UPDTXT  PlatformDscFile BuildFvDir                 [-D Macros]")
-    print ("    GenCfgOpt  HEADER  PlatformDscFile BuildFvDir  InputHFile     [-D Macros]")
-    print ("    GenCfgOpt  GENBSF  PlatformDscFile BuildFvDir  BsfOutFile     [-D Macros]")
-
-def Main():
-    #
-    # Parse the options and args
-    #
-    i = 1
-
-    GenCfgOpt = CGenCfgOpt()
-    while i < len(sys.argv):
-        if sys.argv[i].strip().lower() == "--pcd":
-            BuildOptionPcd.append(sys.argv[i+1])
-            i += 1
-        i += 1
-    argc = len(sys.argv)
-    if argc < 4:
-        Usage()
-        return 1
-    else:
-        DscFile = sys.argv[2]
-        if not os.path.exists(DscFile):
-            print ("ERROR: Cannot open DSC file '%s' !" % DscFile)
-            return 2
-
-        OutFile = ''
-        if argc > 4:
-            if sys.argv[4][0] == '-':
-                Start = 4
-            else:
-                OutFile = sys.argv[4]
-                Start = 5
-            if argc > Start:
-                if GenCfgOpt.ParseMacros(sys.argv[Start:]) != 0:
-                    print ("ERROR: Macro parsing failed !")
-                    return 3
-
-        FvDir = sys.argv[3]
-        if not os.path.exists(FvDir):
-            os.makedirs(FvDir)
-
-        if GenCfgOpt.ParseDscFile(DscFile, FvDir) != 0:
-            print ("ERROR: %s !" % GenCfgOpt.Error)
-            return 5
-
-        if GenCfgOpt.UpdateSubRegionDefaultValue() != 0:
-            print ("ERROR: %s !" % GenCfgOpt.Error)
-            return 7
-
-        if sys.argv[1] == "UPDTXT":
-            Ret = GenCfgOpt.CreateSplitUpdTxt(OutFile)
-            if Ret != 0:
-                # No change is detected
-                if Ret == 256:
-                    print ("INFO: %s !" % (GenCfgOpt.Error))
-                else :
-                    print ("ERROR: %s !" % (GenCfgOpt.Error))
-            return Ret
-        elif sys.argv[1] == "HEADER":
-            if GenCfgOpt.CreateHeaderFile(OutFile) != 0:
-                print ("ERROR: %s !" % GenCfgOpt.Error)
-                return 8
-        elif sys.argv[1] == "GENBSF":
-            if GenCfgOpt.GenerateBsfFile(OutFile) != 0:
-                print ("ERROR: %s !" % GenCfgOpt.Error)
-                return 9
-        else:
-            if argc < 5:
-                Usage()
-                return 1
-            print ("ERROR: Unknown command '%s' !" % sys.argv[1])
-            Usage()
-            return 1
-        return 0
-    return 0
-
-
-if __name__ == '__main__':
-    sys.exit(Main())
diff --git a/QemuFspPkg/Include/FspUpd.h b/QemuFspPkg/Include/FspUpd.h
deleted file mode 100644
index 0845cf600c..0000000000
--- a/QemuFspPkg/Include/FspUpd.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/** @file
-
-Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-* Neither the name of Intel Corporation nor the names of its contributors may
-  be used to endorse or promote products derived from this software without
-  specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
-
-  This file is automatically generated. Please do NOT modify !!!
-
-**/
-
-#ifndef __FSPUPD_H__
-#define __FSPUPD_H__
-
-#include <FspEas.h>
-
-#pragma pack(1)
-
-#define FSPT_UPD_SIGNATURE               0x545F4450554D4551        /* 'QEMUPD_T' */
-
-#define FSPM_UPD_SIGNATURE               0x4D5F4450554D4551        /* 'QEMUPD_M' */
-
-#define FSPS_UPD_SIGNATURE               0x535F4450554D4551        /* 'QEMUPD_S' */
-
-#pragma pack()
-
-#endif
diff --git a/QemuFspPkg/Include/FspmUpd.h b/QemuFspPkg/Include/FspmUpd.h
deleted file mode 100644
index 5931bfdc23..0000000000
--- a/QemuFspPkg/Include/FspmUpd.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/** @file
-
-Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-* Neither the name of Intel Corporation nor the names of its contributors may
-  be used to endorse or promote products derived from this software without
-  specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
-
-  This file is automatically generated. Please do NOT modify !!!
-
-**/
-
-#ifndef __FSPMUPD_H__
-#define __FSPMUPD_H__
-
-#include <FspUpd.h>
-
-#pragma pack(1)
-
-
-
-/** Fsp M Configuration
-**/
-typedef struct {
-
-/** Offset 0x0040 - Debug Serial Port Base address
-  Debug serial port base address. This option will be used only when the 'Serial Port
-  Debug Device' option is set to 'External Device'. 0x00000000(Default).
-**/
-  UINT32                      SerialDebugPortAddress;
-
-/** Offset 0x0044 - Debug Serial Port Type
-  16550 compatible debug serial port resource type. NONE means no serial port support.
-  0x02:MMIO(Default).
-  0:NONE, 1:I/O, 2:MMIO
-**/
-  UINT8                       SerialDebugPortType;
-
-/** Offset 0x0045 - Serial Port Debug Device
-  Select active serial port device for debug. For SOC UART devices,'Debug Serial Port
-  Base' options will be ignored. 0x02:SOC UART2(Default).
-  0:SOC UART0, 1:SOC UART1, 2:SOC UART2, 3:External Device
-**/
-  UINT8                       SerialDebugPortDevice;
-
-/** Offset 0x0046 - Debug Serial Port Stride Size
-  Debug serial port register map stride size in bytes. 0x00:1, 0x02:4(Default).
-  0:1, 2:4
-**/
-  UINT8                       SerialDebugPortStrideSize;
-
-/** Offset 0x0047
-**/
-  UINT8                       UnusedUpdSpace0[49];
-
-/** Offset 0x0078
-**/
-  UINT8                       ReservedFspmUpd[4];
-} FSP_M_CONFIG;
-
-/** Fsp M UPD Configuration
-**/
-typedef struct {
-
-/** Offset 0x0000
-**/
-  FSP_UPD_HEADER              FspUpdHeader;
-
-/** Offset 0x0020
-**/
-  FSPM_ARCH_UPD               FspmArchUpd;
-
-/** Offset 0x0040
-**/
-  FSP_M_CONFIG                FspmConfig;
-
-/** Offset 0x007C
-**/
-  UINT8                       UnusedUpdSpace1[2];
-
-/** Offset 0x007E
-**/
-  UINT16                      UpdTerminator;
-} FSPM_UPD;
-
-#pragma pack()
-
-#endif
diff --git a/QemuFspPkg/Include/FspsUpd.h b/QemuFspPkg/Include/FspsUpd.h
deleted file mode 100644
index a109552c9f..0000000000
--- a/QemuFspPkg/Include/FspsUpd.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/** @file
-
-Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-* Neither the name of Intel Corporation nor the names of its contributors may
-  be used to endorse or promote products derived from this software without
-  specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
-
-  This file is automatically generated. Please do NOT modify !!!
-
-**/
-
-#ifndef __FSPSUPD_H__
-#define __FSPSUPD_H__
-
-#include <FspUpd.h>
-
-#pragma pack(1)
-
-
-/** Fsp S Configuration
-**/
-typedef struct {
-
-/** Offset 0x0040 - BMP Logo Data Size
-  BMP logo data buffer size. 0x00000000(Default).
-**/
-  UINT32                      LogoSize;
-
-/** Offset 0x0044 - BMP Logo Data Pointer
-  BMP logo data pointer to a BMP format buffer. 0x00000000(Default).
-**/
-  UINT32                      LogoPtr;
-
-/** Offset 0x0048 - Graphics Configuration Data Pointer
-  Graphics configuration data used for initialization. 0x00000000(Default).
-**/
-  UINT32                      GraphicsConfigPtr;
-
-/** Offset 0x004C - PCI Temporary MMIO Base
-  PCI Temporary MMIO Base used before full PCI enumeration. 0x80000000(Default).
-**/
-  UINT32                      PciTempResourceBase;
-
-/** Offset 0x0050
-**/
-  UINT8                       UnusedUpdSpace1[32];
-
-/** Offset 0x0070
-**/
-  UINT8                       ReservedFspsUpd;
-} FSP_S_CONFIG;
-
-/** Fsp S UPD Configuration
-**/
-typedef struct {
-
-/** Offset 0x0000
-**/
-  FSP_UPD_HEADER              FspUpdHeader;
-
-/** Offset 0x0020
-**/
-  UINT8                       UnusedUpdSpace0[32];
-
-/** Offset 0x0040
-**/
-  FSP_S_CONFIG                FspsConfig;
-
-/** Offset 0x0071
-**/
-  UINT8                       UnusedUpdSpace2[13];
-
-/** Offset 0x007E
-**/
-  UINT16                      UpdTerminator;
-} FSPS_UPD;
-
-#pragma pack()
-
-#endif
diff --git a/QemuFspPkg/Include/FsptUpd.h b/QemuFspPkg/Include/FsptUpd.h
deleted file mode 100644
index 4340184d3f..0000000000
--- a/QemuFspPkg/Include/FsptUpd.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/** @file
-
-Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-* Neither the name of Intel Corporation nor the names of its contributors may
-  be used to endorse or promote products derived from this software without
-  specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
-
-  This file is automatically generated. Please do NOT modify !!!
-
-**/
-
-#ifndef __FSPTUPD_H__
-#define __FSPTUPD_H__
-
-#include <FspUpd.h>
-
-#pragma pack(1)
-
-
-/** Fsp T Common UPD
-**/
-typedef struct {
-
-/** Offset 0x0020
-**/
-  UINT8                       Revision;
-
-/** Offset 0x0021
-**/
-  UINT8                       Reserved[3];
-
-/** Offset 0x0024
-**/
-  UINT32                      MicrocodeRegionBase;
-
-/** Offset 0x0028
-**/
-  UINT32                      MicrocodeRegionLength;
-
-/** Offset 0x002C
-**/
-  UINT32                      CodeRegionBase;
-
-/** Offset 0x0030
-**/
-  UINT32                      CodeRegionLength;
-
-/** Offset 0x0034
-**/
-  UINT8                       Reserved1[12];
-} FSPT_COMMON_UPD;
-
-/** Fsp T UPD Configuration
-**/
-typedef struct {
-
-/** Offset 0x0000
-**/
-  FSP_UPD_HEADER              FspUpdHeader;
-
-/** Offset 0x0020
-**/
-  FSPT_COMMON_UPD             FsptCommonUpd;
-
-/** Offset 0x0040
-**/
-  UINT8                       ReservedFsptUpd1[32];
-
-/** Offset 0x0060
-**/
-  UINT8                       UnusedUpdSpace0[48];
-
-/** Offset 0x0090
-**/
-  UINT16                      UpdTerminator;
-} FSPT_UPD;
-
-#pragma pack()
-
-#endif
diff --git a/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h b/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h
index 0ecdfbdbdf..04fac6a291 100644
--- a/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h
+++ b/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h
@@ -24,6 +24,7 @@
 #include <Library/PcdLib.h>
 #include <Library/BaseMemoryLib.h>
 #include <Library/FspCommonLib.h>
+#include <FspUpd.h>
 #include <FspmUpd.h>
 #include <FspsUpd.h>
 
diff --git a/QemuFspPkg/QemuFspPkg.dsc b/QemuFspPkg/QemuFspPkg.dsc
index d216b78b58..74ef64c0a0 100644
--- a/QemuFspPkg/QemuFspPkg.dsc
+++ b/QemuFspPkg/QemuFspPkg.dsc
@@ -159,194 +159,6 @@
   gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel        | 0x80000047
 !endif
 
-[PcdsDynamicVpd.Upd]
-  #
-  # This section is not used by the normal build process
-  # However, FSP will use dedicated tool to handle it and generate a
-  # VPD similar binary block (User Configuration Data). This block will
-  # be accessed through a generated data structure directly rather than
-  # PCD services. This is for size consideration.
-  # Format:
-  #   gQemuFspPkgTokenSpaceGuid.Updxxxxxxxxxxxxn      | OFFSET | LENGTH | VALUE
-  # Only simple data type is supported
-  #
-
-  #
-  # Comments with !BSF will be used to generate BSF file
-  # Comments with !HDR will be used to generate H header file
-  #
-
-  # Global definitions in BSF
-  # !BSF PAGES:{MEM:"FSP MemoryInit Settings", SIL:"FSP SiliconInit Settings"}
-  # !BSF BLOCK:{NAME:"Apollo Lake Platform", VER:"0.1"}
-
-  # !BSF FIND:{APLUPD_T}
-  # !HDR COMMENT:{FSP_UPD_HEADR:FSP UPD Header}
-  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:START}
-  # FsptUpdSignature: {QEMUPD_T}
-  gQemuFspPkgTokenSpaceGuid.Signature                   | 0x0000 | 0x08 | 0x545F4450554D4551
-  # !BSF NAME:{FsptUpdRevision}  TYPE:{None}
-  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0008 | 0x01 | 0x01
-  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:END}
-  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0009 | 0x17 | {0x00}
-
-  # !HDR COMMENT:{FSPT_COMMON_UPD:Fsp T Common UPD}
-  # !HDR EMBED:{FSPT_COMMON_UPD:FsptCommonUpd:START}
-  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0020 | 0x01 | 0x01
-  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0021 | 0x03 | {0x00}
-
-  # Base address of the microcode region.
-  gQemuFspPkgTokenSpaceGuid.MicrocodeRegionBase         | 0x0024 | 0x04 | 0x00000000
-
-  # Length of the microcode region.
-  gQemuFspPkgTokenSpaceGuid.MicrocodeRegionLength       | 0x0028 | 0x04 | 0x00000000
-
-  # Base address of the cacheable flash region.
-  gQemuFspPkgTokenSpaceGuid.CodeRegionBase              | 0x002C | 0x04 | 0x00000000
-
-  # Length of the cacheable flash region.
-  gQemuFspPkgTokenSpaceGuid.CodeRegionLength            | 0x0030 | 0x04 | 0x00000000
-
-  # !HDR EMBED:{FSPT_COMMON_UPD:FsptCommonUpd:END}
-  gQemuFspPkgTokenSpaceGuid.Reserved1                   | 0x0034 | 0x0C | {0x00}
-
-  # !HDR COMMENT:{FSP_T_CONFIG:Fsp T Configuration}
-  # !HDR EMBED:{FSP_T_CONFIG:FsptConfig:START}
-
-  # !HDR EMBED:{FSP_T_CONFIG:FsptConfig:END}
-  gQemuFspPkgTokenSpaceGuid.ReservedFsptUpd1             | 0x0040 | 0x20 | {0x00}
-
-  # Note please keep "UpdTerminator" at the end of each UPD region.
-  # The tool will use this field to determine the actual end of the UPD data
-  # structure.
-  gQemuFspPkgTokenSpaceGuid.UpdTerminator               | 0x0090 | 0x02 | 0x55AA
-
-  ################################################################################
-  #
-  # UPDs consumed in FspMemoryInit Api
-  #
-  ################################################################################
-  # !BSF FIND:{APLUPD_M}
-  # !HDR COMMENT:{FSP_UPD_HEADER:FSP UPD Header}
-  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:START}
-  # FspmUpdSignature: {APLUPD_M}
-  gQemuFspPkgTokenSpaceGuid.Signature                   | 0x0000 | 0x08 | 0x4D5F4450554D4551
-  # !BSF NAME:{FspmUpdRevision}  TYPE:{None}
-  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0008 | 0x01 | 0x01
-  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:END}
-  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0009 | 0x17 | {0x00}
-
-  # !HDR COMMENT:{FSPM_ARCH_UPD:Fsp M Architectural UPD}
-  # !HDR EMBED:{FSPM_ARCH_UPD:FspmArchUpd:START}
-  # !BSF PAGE:{MEM}
-
-  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0020 | 0x01 | 0x01
-
-  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0021 | 0x03 | {0x00}
-
-  # !HDR STRUCT:{VOID*}
-  gQemuFspPkgTokenSpaceGuid.NvsBufferPtr                | 0x0024 | 0x04 | 0x00000000
-
-  # !HDR STRUCT:{VOID*}
-  # !BSF NAME:{StackBase}
-  # !BSF HELP:{Stack base for FSP use. Default: 0xFEF16000}
-  gQemuFspPkgTokenSpaceGuid.StackBase                   | 0x0028 | 0x04 | $(CAR_BLD_REGION_SIZE)
-
-  # !BSF NAME:{StackSize}
-  # !BSF HELP:{To pass the stack size for FSP use. Bootloader can programmatically get the FSP requested StackSize by using the defaults in the FSP-M component. This is the minimum stack size expected by this revision of FSP. Default: 0x2A000}
-  gQemuFspPkgTokenSpaceGuid.StackSize                   | 0x002C | 0x04 | $(CAR_FSP_REGION_SIZE)
-
-  # !BSF NAME:{BootLoaderTolumSize}
-  # !BSF HELP:{To pass Bootloader Tolum size.}
-  gQemuFspPkgTokenSpaceGuid.BootLoaderTolumSize         | 0x0030 | 0x04 | 0x00000000
-
-  # !BSF NAME:{Bootmode}
-  # !BSF HELP:{To maintain Bootmode details.}
-  gPlatformFspPkgTokenSpaceGuid.Bootmode                   | 0x0034 | 0x04 | 0x00000000
-
-  # !HDR EMBED:{FSPM_ARCH_UPD:FspmArchUpd:END}
-  gQemuFspPkgTokenSpaceGuid.Reserved1                   | 0x0038 | 0x08 | {0x00}
-
-  # !HDR COMMENT:{FSP_M_CONFIG:Fsp M Configuration}
-  # !HDR EMBED:{FSP_M_CONFIG:FspmConfig:START}
-  # !BSF NAME:{Debug Serial Port Base address}
-  # !BSF TYPE:{EditNum, HEX, (0x00000000,0xFFFFFFFF)}
-  # !BSF HELP:{Debug serial port base address. This option will be used only when the 'Serial Port Debug Device'}
-  # !BSF HELP:{+ option is set to 'External Device'. 0x00000000(Default).}
-  gQemuFspPkgTokenSpaceGuid.SerialDebugPortAddress      | 0x0040 | 0x04 | 0x00000000
-
-  # !BSF NAME:{Debug Serial Port Type} TYPE:{Combo}
-  # !BSF OPTION:{0:NONE, 1:I/O, 2:MMIO}
-  # !BSF HELP:{16550 compatible debug serial port resource type. NONE means no serial port support. 0x02:MMIO(Default).}
-  gQemuFspPkgTokenSpaceGuid.SerialDebugPortType         | 0x0044 | 0x01 | 0x02
-
-  # !BSF NAME:{Serial Port Debug Device} TYPE:{Combo}
-  # !BSF OPTION:{0:SOC UART0, 1:SOC UART1, 2:SOC UART2, 3:External Device}
-  # !BSF HELP:{Select active serial port device for debug. }
-  # !BSF HELP:{+For SOC UART devices,'Debug Serial Port Base' options will be ignored. 0x02:SOC UART2(Default).}
-  gQemuFspPkgTokenSpaceGuid.SerialDebugPortDevice       | 0x0045 | 0x01 | 0x02
-
-  # !BSF NAME:{Debug Serial Port Stride Size} TYPE:{Combo}
-  # !BSF OPTION:{0:1, 2:4}
-  # !BSF HELP:{Debug serial port register map stride size in bytes. 0x00:1, 0x02:4(Default).}
-  gQemuFspPkgTokenSpaceGuid.SerialDebugPortStrideSize   | 0x0046 | 0x01 | 0x02
-
-
-  # !HDR EMBED:{FSP_M_CONFIG:FspmConfig:END}
-  gQemuFspPkgTokenSpaceGuid.ReservedFspmUpd             | 0x0078 | 0x04 | {0x00}
-
-
-  # Note please keep "UpdTerminator" at the end of each UPD region.
-  # The tool will use this field to determine the actual end of the UPD data
-  # structure.
-  gQemuFspPkgTokenSpaceGuid.UpdTerminator               | 0x007E | 0x02 | 0x55AA
-
-  ################################################################################
-  #
-  # UPDs consumed in FspSiliconInit Api
-  #
-  ################################################################################
-  # !BSF FIND:{APLUPD_S}
-  # !HDR COMMENT:{FSP_UPD_HEADER:FSP UPD Header}
-  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:START}
-  # FspsUpdSignature: {APLUPD_S}
-  gQemuFspPkgTokenSpaceGuid.Signature                   | 0x0000 | 0x08 | 0x535F4450554D4551
-  # !BSF NAME:{FspsUpdRevision}  TYPE:{None}
-  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0008 | 0x01 | 0x01
-  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:END}
-  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0009 | 0x17 | {0x00}
-
-  # !HDR COMMENT:{FSP_S_CONFIG:Fsp S Configuration}
-  # !HDR EMBED:{FSP_S_CONFIG:FspsConfig:START}
-  # !BSF PAGE:{SIL}
-
-  # !BSF NAME:{BMP Logo Data Size}
-  # !BSF TYPE:{Reserved}
-  # !BSF HELP:{BMP logo data buffer size. 0x00000000(Default).}
-  gQemuFspPkgTokenSpaceGuid.LogoSize                    | 0x0040 | 0x04 | 0x00000000
-
-  # !BSF NAME:{BMP Logo Data Pointer}
-  # !BSF TYPE:{Reserved}
-  # !BSF HELP:{BMP logo data pointer to a BMP format buffer. 0x00000000(Default).}
-  gQemuFspPkgTokenSpaceGuid.LogoPtr                     | 0x0044 | 0x04 | 0x00000000
-
-  # !BSF NAME:{Graphics Configuration Data Pointer}
-  # !BSF TYPE:{Reserved}
-  # !BSF HELP:{Graphics configuration data used for initialization. 0x00000000(Default).}
-  gQemuFspPkgTokenSpaceGuid.GraphicsConfigPtr           | 0x0048 | 0x04 | 0x00000000
-
-  # !BSF NAME:{PCI Temporary MMIO Base}
-  # !BSF TYPE:{Reserved}
-  # !BSF HELP:{PCI Temporary MMIO Base used before full PCI enumeration. 0x80000000(Default).}
-  gQemuFspPkgTokenSpaceGuid.PciTempResourceBase         | 0x004C | 0x04 | 0x80000000
-
-  # !HDR EMBED:{FSP_S_CONFIG:FspsConfig:END}
-  gQemuFspPkgTokenSpaceGuid.ReservedFspsUpd             | 0x0070 | 0x01 | 0x00
-
-  # Note please keep "UpdTerminator" at the end of each UPD region.
-  # The tool will use this field to determine the actual end of the UPD data
-  # structure.
-  gQemuFspPkgTokenSpaceGuid.UpdTerminator               | 0x007E | 0x02 | 0x55AA
 
 ###################################################################################################
 #
diff --git a/QemuFspPkg/QemuFspUpd.yaml b/QemuFspPkg/QemuFspUpd.yaml
new file mode 100644
index 0000000000..5e7c68e683
--- /dev/null
+++ b/QemuFspPkg/QemuFspUpd.yaml
@@ -0,0 +1,255 @@
+## @file
+#
+#  Slim Bootloader CFGDATA Default File.
+#
+#  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+
+variable:
+  FSP_PACKAGE                    : QemuFspPkg
+  FSP_IMAGE_ID                   : 0x245053464D455124  # $QEMFSP$
+  FSP_IMAGE_REV                  : 0x00001000
+  CAR_BASE_ADDRESS               : 0x00000000
+  CAR_REGION_SIZE                : 0x00080000
+  CAR_BLD_REGION_SIZE            : 0x00070000
+  CAR_FSP_REGION_SIZE            : 0x00010000
+  PLATFORM_NAME                  : QemuFspPkg
+  PLATFORM_GUID                  : 1BEDB57A-7904-406e-8486-C89FC7FB39EE
+  PLATFORM_VERSION               : 0.1
+  DSC_SPECIFICATION              : 0x00010005
+  OUTPUT_DIRECTORY               : Build/QemuFspPkg
+  SUPPORTED_ARCHITECTURES        : IA32
+  BUILD_TARGETS                  : DEBUG|RELEASE
+  SKUID_IDENTIFIER               : DEFAULT
+  FLASH_DEFINITION               : QemuFspPkg/QemuFspPkg.fdf
+  FSP_T_UPD_TOOL_GUID            : 34686CA3-34F9-4901-B82A-BA630F0714C6
+  FSP_M_UPD_TOOL_GUID            : 39A250DB-E465-4DD1-A2AC-E2BD3C0E2385
+  FSP_S_UPD_TOOL_GUID            : CAE3605B-5B34-4C85-B3D7-27D54273C40F
+  FSP_T_UPD_FFS_GUID             : 70BCF6A5-FFB1-47D8-B1AE-EFE5508E23EA
+  FSP_M_UPD_FFS_GUID             : D5B86AEA-6AF7-40D4-8014-982301BC3D89
+  FSP_S_UPD_FFS_GUID             : E3CD9B18-998C-4F76-B65E-98B154E5446F
+
+
+template:
+
+
+configs:
+  - $ACTION      :
+      page         : MEM::"FSP MemoryInit Settings", SIL::"FSP SiliconInit Settings"
+
+  - FSPT_UPD:
+
+    - FSP_UPD_HEADER :
+      - Signature    :
+          length       : 0x08
+          value        : 0x545F4450554D4551
+      - Revision     :
+          name         : FsptUpdRevision
+          type         : None
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x17
+          value        : {0x00}
+
+    - FSPT_COMMON_UPD :
+      - Revision     :
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x03
+          value        : {0x00}
+      - MicrocodeRegionBase :
+          length       : 0x04
+          value        : 0x00000000
+      - MicrocodeRegionLength :
+          length       : 0x04
+          value        : 0x00000000
+      - CodeRegionBase :
+          length       : 0x04
+          value        : 0x00000000
+      - CodeRegionLength :
+          length       : 0x04
+          value        : 0x00000000
+      - Reserved1    :
+          length       : 0x0C
+          value        : {0x00}
+
+    - FSP_T_CONFIG :
+      - ReservedFsptUpd1 :
+          length       : 0x20
+          value        : {0x00}
+      - UnusedUpdSpace0 :
+          length       : 0x30
+          value        : { 0 }
+      - UpdTerminator :
+          length       : 0x02
+          value        : 0x55AA
+
+  - FSPM_UPD:
+    - FSP_UPD_HEADER :
+      - Signature    :
+          length       : 0x08
+          value        : 0x4D5F4450554D4551
+      - Revision     :
+          name         : FspmUpdRevision
+          type         : None
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x17
+          value        : {0x00}
+
+    - FSPM_ARCH_UPD :
+      - $ACTION      :
+          page         : MEM
+      - Revision     :
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x03
+          value        : {0x00}
+      - NvsBufferPtr :
+          struct       : VOID*
+          length       : 0x04
+          value        : 0x00000000
+      - StackBase    :
+          struct       : VOID*
+          name         : StackBase
+          help         : >
+                         Stack base for FSP use. Default- 0xFEF16000
+          length       : 0x04
+          value        : $(CAR_BLD_REGION_SIZE)
+      - StackSize    :
+          name         : StackSize
+          help         : >
+                         To pass the stack size for FSP use. Bootloader can programmatically get the FSP requested StackSize by using the defaults in the FSP-M component. This is the minimum stack size expected by this revision of FSP. Default- 0x2A000
+          length       : 0x04
+          value        : $(CAR_FSP_REGION_SIZE)
+      - BootLoaderTolumSize :
+          name         : BootLoaderTolumSize
+          help         : >
+                         To pass Bootloader Tolum size.
+          length       : 0x04
+          value        : 0x00000000
+      - Bootmode     :
+          name         : Bootmode
+          help         : >
+                         To maintain Bootmode details.
+          length       : 0x04
+          value        : 0x00000000
+      - Reserved1    :
+          length       : 0x08
+          value        : {0x00}
+
+    - FSP_M_CONFIG :
+      - SerialDebugPortAddress :
+          name         : Debug Serial Port Base address
+          type         : EditNum, HEX, (0x00000000,0xFFFFFFFF)
+          help         : >
+                         Debug serial port base address. This option will be used only when the 'Serial Port Debug Device'
+                         option is set to 'External Device'. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - SerialDebugPortType :
+          name         : Debug Serial Port Type
+          type         : Combo
+          option       : 0:NONE, 1:I/O, 2:MMIO
+          help         : >
+                         16550 compatible debug serial port resource type. NONE means no serial port support. 0x02:MMIO(Default).
+          length       : 0x01
+          value        : 0x02
+      - SerialDebugPortDevice :
+          name         : Serial Port Debug Device
+          type         : Combo
+          option       : 0:SOC UART0, 1:SOC UART1, 2:SOC UART2, 3:External Device
+          help         : >
+                         Select active serial port device for debug.
+                         For SOC UART devices,'Debug Serial Port Base' options will be ignored. 0x02:SOC UART2(Default).
+          length       : 0x01
+          value        : 0x02
+      - SerialDebugPortStrideSize :
+          name         : Debug Serial Port Stride Size
+          type         : Combo
+          option       : 0:1, 2:4
+          help         : >
+                         Debug serial port register map stride size in bytes. 0x00:1, 0x02:4(Default).
+          length       : 0x01
+          value        : 0x02
+
+      - UnusedUpdSpace1 :
+          length       : 0x31
+          value        : { 0 }
+      - ReservedFspmUpd :
+          length       : 0x04
+          value        : {0x00}
+      - UnusedUpdSpace2 :
+          length       : 0x2
+          value        : { 0 }
+      - UpdTerminator :
+          length       : 0x02
+          value        : 0x55AA
+
+  - FSPS_UPD:
+    - FSP_UPD_HEADER :
+      - Signature    :
+          length       : 0x08
+          value        : 0x535F4450554D4551
+      - Revision     :
+          name         : FspsUpdRevision
+          type         : None
+          length       : 0x01
+          value        : 0x01
+      - Reserved     :
+          length       : 0x17
+          value        : {0x00}
+
+    - FSP_S_CONFIG :
+      - $ACTION      :
+          page         : SIL
+      - UnusedUpdSpace3 :
+          length       : 0x20
+          value        : { 0 }
+      - LogoSize     :
+          name         : BMP Logo Data Size
+          type         : Reserved
+          help         : >
+                         BMP logo data buffer size. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - LogoPtr      :
+          name         : BMP Logo Data Pointer
+          type         : Reserved
+          help         : >
+                         BMP logo data pointer to a BMP format buffer. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - GraphicsConfigPtr :
+          name         : Graphics Configuration Data Pointer
+          type         : Reserved
+          help         : >
+                         Graphics configuration data used for initialization. 0x00000000(Default).
+          length       : 0x04
+          value        : 0x00000000
+      - PciTempResourceBase :
+          name         : PCI Temporary MMIO Base
+          type         : Reserved
+          help         : >
+                         PCI Temporary MMIO Base used before full PCI enumeration. 0x80000000(Default).
+          length       : 0x04
+          value        : 0x80000000
+      - UnusedUpdSpace4 :
+          length       : 0x20
+          value        : { 0 }
+      - ReservedFspsUpd :
+          length       : 0x01
+          value        : 0x00
+      - UnusedUpdSpace5 :
+          length       : 0xd
+          value        : { 0 }
+      - UpdTerminator :
+          length       : 0x02
+          value        : 0x55AA
-- 
2.19.1.windows.1

